const rootData = [{
		"id": "5efb4c5d13f8b244e57cc632",
		"author_id": "5b0eaaf38a4f51e140d9437d",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FtqTjdKjmFfToaLhm5Lvn8YI0c0E\" alt=\"nodejs_interprise_practice.png\"></p>\n<p>在和一些 Nodeer 童鞋的分享交流过程中，也会听到一些声音：“Node.js 在企业中是如何应用的？有哪些大厂在实践？”，于是公众号 “Nodejs技术栈” 自 19 年 8 月开始陆陆续续给大家分享一些 Node.js 在企业中的应用实践，希望给正在学习、使用 Node.js 的童鞋一些参考。</p>\n<p><strong>Nodejs 生态的建设需要大家共同努力，如有企业实践的欢迎补充让更多朋友能够看到</strong>！谢谢大家！</p>\n<h2>阿里</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/63Lv9qwsoXocCE3sIhsIPA\">看优酷 Nodejs 重构之路 Serverless SSR 未来可期</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/101917567\">“云”端的语雀：用 JavaScript 全栈打造商业级应用</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/f5xIN9d7s011_gXej84MJw\">独家解读：淘宝使用 Node.js 的 TypeScript 多场景开发和实践</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/ghciI1dj9dve6Bsrf8Yj1w\">基于阿里云的 Node.js 稳定性实践</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/wIYlSPSJSK2eHbk48SFQLw\">蚂蚁金服 Node.js 开荒史 - 摸爬滚打才不负功名尘土</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/oKcQXj3CWt1Ts_tOtw7QTg\">基于 Node.js 的 Serverless 架构实践</a></li>\n<li><a href=\"https://www.yuque.com/preview/yuque/0/2020/pdf/84135/1578575086211-802410a9-a833-47ce-b612-b6f6108285e6.pdf\">用 Node.js 构建海量页面渲染服务</a></li>\n<li><a href=\"https://www.yuque.com/preview/yuque/0/2020/pdf/84135/1578577070295-d62924f6-a34c-463f-a6b5-ea657cfd038d.pdf\">Node.js Web 框架研发与实践</a></li>\n<li><a href=\"https://github.com/tmallfe/tmallfe.github.io/issues/28\">天猫双11前端分享系列（四）：大规模 Node.js 应用</a>（上）</li>\n<li><a href=\"https://github.com/tmallfe/tmallfe.github.io/issues/30\">天猫双11前端分享系列（六）：大规模 Node.js 应用（续）</a>（下）</li>\n</ul>\n<h2>腾讯</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/7lA2-mCM9GR3BekWH6hB2Q\">腾讯视频 Node.js 服务是如何支撑国庆阅兵直播高并发的？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/GGrb7Oex7SqtwzIKAXSFVg\">Node.js 部署和运维工作量降低 80%，腾讯 NOW 直播是怎么做到的？</a></li>\n</ul>\n<h2>携程</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/yuK3MvgMlYE5thEx6e8rtQ\">浅谈 Node.js 在携程的应用</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/NU7Hm96-cngvUCOF2LOpMA\">携程机票 Node.js 开发实践</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/ndPlZJWM9pxusGMY8C0eyA\">Node.js 在携程的落地和最佳实践</a></li>\n</ul>\n<h2>转转</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/1rjvoOySe-dcxn8fWE8BMQ\">Node.js 在转转的微服务实践（一）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/HyoCCOD0SqcGA7Ajt7GWuA\">Node.js 在转转的微服务实践（二）</a></li>\n</ul>\n<h2>宋小菜</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/HCKWKhnlDwAGo5s797W7jA\">框架设计：如何基于 Egg 设计 Node 的服务框架</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/j4tAMFzlGQ5O9q768KE9Cg\">为什么 Node 是小菜前端团队的核心技术栈</a></li>\n</ul>\n<h2>百度</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/2ZnBR2Ki7VJCLmtVT4oOsw\">商业化场景下，百度如何实践 Node.js 架构？</a></li>\n</ul>\n<h2>苏宁</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/Dr7k1JDE6crJoYU7fmEcTw\">苏宁的 Node.js 实践：不低于Java的渲染性能、安全稳定迭代快</a></li>\n</ul>\n<h2>京东</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/jnIqOr-zhybgZbejKLZikg\">记一次京东 Node.js 直出服务的性能优化</a></li>\n</ul>\n<h2>爱奇艺</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/J9cYX8DkZFb6iAJt6E0THQ\">爱奇艺 PC Web Node.js 中间层实践</a></li>\n</ul>\n<h2>去哪儿</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/osgtwTLJhJJmF0bHFmKgUg\">去哪儿网前后端分离实践（含 Node.js 应用实践）</a></li>\n</ul>\n<h2>个推</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/e_w0Q1T1F8yZWHeoUaOTQw\">Node.js 在个推的微服务实践：基于容器的一站式命令行工具链</a></li>\n</ul>\n<h2>有赞</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/vTL98USoRyJrcu4ny9r0ZQ\">Node.js 在有赞的实践分享</a></li>\n</ul>\n<h2>微医</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/OeZyo7MZhadGjKV83LZnhA\">Node.js 在微医的应用场景及实践</a></li>\n</ul>\n<h2>贝壳找房</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/umr-SZXflTy9XQoRRf56Rg\">2019大前端秘籍：贝壳找房多端提效和性能质量优化实践</a></li>\n</ul>\n<h2>途牛</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/TI8VgCpToFQDrITLyac3Rg\">Node.js 微应用在途牛的实践</a></li>\n</ul>\n<h2>滴滴</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/IsnQCEC8oehDmdmpbXWKwQ\">NodeX Component - 滴滴集团 Node.js 生态组件体系</a></li>\n</ul>\n<h2>58 同城</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/wfMl-2wFXSpx8QjTckJxCw\">基于 SFF 一站式 Nodejs 服务管理平台实践</a></li>\n</ul>\n<h2>网易</h2>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/138925672\">网易智慧企业 Node.js 实践（1）| Node 应用架构设计和 React 同构</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/142547821\">网易智慧企业 Node.js 实践（2）| 平滑发布和前端代码</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/142551285\">网易智慧企业 Node.js 实践（3）| 灰度环境和应用监控</a></li>\n</ul>\n<h2></h2>\n<hr>\n<p>如果您正在实践 Node.js，很期待能收到您的分享，可以关注公众号 “Nodejs技术栈” 在后台向我投稿，后期都会进行整理放在 <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/practice/enterprise.md\">Github</a> 以供大家学习和实践参考。</p>\n<p><strong>作者简介</strong>：五月君，软件设计师，<a href=\"https://www.imooc.com/u/2667395\">慕课网认证作者</a>，公众号 “<a href=\"https://nodejsred.oss-cn-shanghai.aliyuncs.com/node_roadmap_wx.jpg?x-oss-process=style/may\">Nodejs技术栈</a>” 作者，热爱技术、喜欢分享的 90 后青年，欢迎关注 Github 开源项目 <a href=\"https://www.nodejs.red\">https://www.nodejs.red</a></p>\n</div>",
		"title": "Node.js 在企业中的应用实践集锦 - 2020 年中汇总",
		"last_reply_at": "2020-10-04T12:59:45.432Z",
		"good": true,
		"top": true,
		"reply_count": 17,
		"visit_count": 61167,
		"create_at": "2020-06-30T14:29:49.729Z",
		"author": {
			"loginname": "Q-Angelo",
			"avatar_url": "https://avatars0.githubusercontent.com/u/17956058?v=4&s=120"
		}
	}, {
		"id": "5e16978581adfe260207a8c1",
		"author_id": "54009f5ccd66f2eb37190485",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><h2>活动信息</h2>\n<p><img src=\"//static.cnodejs.org/Fsqzwb41k7ivzIJn810EEwPQ_2it\" alt=\"1111.png\"></p>\n<p><img src=\"//static.cnodejs.org/Fu_XCoMAB8uUlFYPGWQ3ncssCb8t\" alt=\"2222.png\"></p>\n<p><img src=\"//static.cnodejs.org/Fge-hr_LF_guf0BbwQ9xmi0unnNi\" alt=\"33333.png\"></p>\n<p>本次活动需要提前报名，场地大约有100人</p>\n<p>报名连接</p>\n<p><a href=\"https://www.huodongxing.com/event/5526816284100?utm_source=%E5%8F%91%E7%8E%B0%E6%B4%BB%E5%8A%A8%E9%A1%B5&amp;utm_medium=&amp;utm_campaign=eventspage\">https://www.huodongxing.com/event/5526816284100?utm_source=发现活动页&amp;utm_medium=&amp;utm_campaign=eventspage</a></p>\n<h2>PPT</h2>\n<p><a href=\"https://github.com/i5ting/nodeparty-beijing-2020-1-11\">https://github.com/i5ting/nodeparty-beijing-2020-1-11</a></p>\n<h2>照片</h2>\n<p>龙佳文\n<img src=\"//static.cnodejs.org/Fg4dIjPNKksKiOMmyIgGMEg1087O\" alt=\"111 1.jpg\"></p>\n<p>十忆\n<img src=\"//static.cnodejs.org/Fs9J2dxbgickUDOzM7Vwuxd7HVKF\" alt=\"222 1.jpg\">\n狼叔\n<img src=\"//static.cnodejs.org/Fhc9AmVNEbqAdmxOUTYwIN7XdYU_\" alt=\"3333 1.jpg\">\n王东\n<img src=\"//static.cnodejs.org/FssLOS3hMlVq658eD_yb3CJpeW8C\" alt=\"4444 1.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/Fsuj39b-PoVOS65vAoVgFqbR9m8Q\" alt=\"5555 1.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FiTD21bRAzZZbpCueJRk7Uq-Ik7i\" alt=\"7777 1.jpg\">\n现场提问\n<img src=\"//static.cnodejs.org/Fm6ssdq_P6JNaftwAZ_AyiXtVIxb\" alt=\"8888 1.jpg\">\n流司\n<img src=\"//static.cnodejs.org/FoqgjwSNssTlJ1ufnowc1jxx_imR\" alt=\"9923 1.jpg\">\n现场提问\n<img src=\"//static.cnodejs.org/FplNNONJOacRNbvnvc7EBl1sgN8U\" alt=\"9999 1.jpg\">\n现场\n<img src=\"//static.cnodejs.org/Fl--jBm9nfRCmNPCvL92TrlkvdGT\" alt=\"11212 1.jpg\"></p>\n<p>圆桌会\n<img src=\"//static.cnodejs.org/Fq7xH6d9K1bor6ixUFY1AEO4d8GU\" alt=\"23323e4ds 1.jpg\">\n<img src=\"//static.cnodejs.org/FulUvueqoTJ8nIGlOgJTD1JFGDPA\" alt=\"322332.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/Ftw6oRg8G-eeqQ2SLrwiaj671sMF\" alt=\"稳稳稳.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FozWsIovHilxYBlJ-I8LmYW-gNhi\" alt=\"32323.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/Fvhek3xeqE4afj41AuB5Vuj7MwSr\" alt=\"43434.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FvM4WhrhpkRT9sZ3CxsbGy8OX7bH\" alt=\"55545.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/Fh7MgA9zXpT3Gc-1UfXsd3o8FB6F\" alt=\"111110.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/Fr6oow-uHpFkkoVo2xIaw3Xm-gdI\" alt=\"232323.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/Fl3A1Ijt8IeE9XHT9DNNUM_I0OkB\" alt=\"232332.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FobbWO7B2JwwszK80ZpJT8Pl6f0Y\" alt=\"322323.jpg\">\n<img src=\"//static.cnodejs.org/Fr7qQvzHT6pLInnX9m6JeFZEjKYC\" alt=\"812312.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FinFnUdjTZjt2DAdjC5H-DsYZ4Fa\" alt=\"882323.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/Fq-nKPQt4JeiBZAQKft6vW49pGiB\" alt=\"3434389.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FuAt3QuZ-Y9E21EMrkn05JAcPLsf\" alt=\"9999923.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FkpIr82doXBBk7VH1aGM6zD16qZ-\" alt=\"23323232323.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FiKYZ46Ilm5OVT_Tunhmga8x-vrr\" alt=\"232323232332.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FqOE05r204gsYDWp-m9p04Vf1ME_\" alt=\"aaa.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FmRRAzINYs-j5hF-n7-LZKscD23e\" alt=\"bbbb.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FjIIelIuczqPkJjWSKC5wEtv3uzD\" alt=\"cccc.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FjIIelIuczqPkJjWSKC5wEtv3uzD\" alt=\"cccc.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FtponmJNP2UD0qemwD_1vBBa0ibK\" alt=\"dddd.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/Fv0LVdt1X6RizMg5gp2CerH1pIMH\" alt=\"dfdfd.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/Fgw6rAtxlJg9fWLlQNM4gwozWlVj\" alt=\"eeeee.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FlnX4CFVmxrFQXmNWYQuwt6Ar4Et\" alt=\"EmptyName 2.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FnnoaFaMof3IxOR9sWJIj6jrjcPx\" alt=\"hjkl;'.jpg\"></p>\n<p>王东\n<img src=\"//static.cnodejs.org/FhNqWIas9yk1XuYvNHtijUzB40BK\" alt=\"jhklsd.jpg\"></p>\n<p>嘉宾合影\n<img src=\"//static.cnodejs.org/FvKMqpc7UZhVeRKXUNvtY8FuBAEh\" alt=\"上3.jpg\"></p>\n<p>狼书签名\n<img src=\"//static.cnodejs.org/FgxEWL85ZMEA8qpVakAvvSUWEmVd\" alt=\"23e4232 1.jpg\"></p>\n<h2>视频</h2>\n<p>面向B端工作台的微前端方案-ConsoleOS-徐博文\n<a href=\"https://edu.talkingdata.com/open-class?id=142\">https://edu.talkingdata.com/open-class?id=142</a></p>\n<p>Serverless在美团的实践-龙佳文\n<a href=\"https://edu.talkingdata.com/open-class?id=143\">https://edu.talkingdata.com/open-class?id=143</a></p>\n<p>前端生态建设在瓜子的落地实践-王东\n<a href=\"https://edu.talkingdata.com/open-class?id=144\">https://edu.talkingdata.com/open-class?id=144</a></p>\n<p>Egg-React-SSR深度解析-张宇昂\n<a href=\"https://edu.talkingdata.com/open-class?id=145\">https://edu.talkingdata.com/open-class?id=145</a></p>\n<p>如何融入并贡献开源-Justjavac\n<a href=\"https://edu.talkingdata.com/open-class?id=146\">https://edu.talkingdata.com/open-class?id=146</a></p>\n<p>圆桌讨论\n<a href=\"https://edu.talkingdata.com/open-class?id=147\">https://edu.talkingdata.com/open-class?id=147</a></p>\n</div>",
		"title": "2020年1月11日Node party@北京成功举办，附照片、视频和ppt",
		"last_reply_at": "2020-09-28T03:40:52.790Z",
		"good": true,
		"top": true,
		"reply_count": 14,
		"visit_count": 58099,
		"create_at": "2020-01-09T03:01:25.190Z",
		"author": {
			"loginname": "i5ting",
			"avatar_url": "https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"
		}
	}, {
		"id": "5ee1ee83b703280f0bcb922a",
		"author_id": "575eaa97c1518403160a45c4",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p>欢迎加入官方钉钉群 <strong>35149528</strong> 一起讨论</p>\n<p>如果项目对你有帮助，访问 <a href=\"https://github.com/hyj1991/easy-monitor\">https://github.com/hyj1991/easy-monitor</a> 来 star 支持下作者。</p>\n<h2>I. 项目简介</h2>\n<p>作为一名 Node.js 开发者，深知对于初涉服务端领域的前端同学来说，在引入 Node.js 的时候很容易心里没底：</p>\n<ul>\n<li>我的应用内存一点点上涨，是为什么呢？</li>\n<li>我的应用为何响应时间这么慢？</li>\n<li>我的代码性能瓶颈在那里呢？</li>\n<li>…</li>\n</ul>\n<p>今天我们很荣幸能回馈社区，正式开源 <a href=\"https://github.com/hyj1991/easy-monitor\">Easy-Monitor</a> 3.0 版本，它是一款Node.js 应用性能监控与线上故障定位解决方案。</p>\n<p>旨在 Node.js 的开源生态工具链上，做一些能帮助到想使用和正在使用 Node.js 的开发者更好地感知自己的 Node.js 应用状态，以更好地面对来自性能和稳定性方面的挑战。</p>\n<p><strong>3.0 具备以下新特性：</strong></p>\n<ul>\n<li>针对 Node.js 进程与系统指标的性能监控</li>\n<li>错误日志展示与依赖 Npm 模块安全风险提示</li>\n<li>自定义智能运维告警与线上进程实时状态导出</li>\n</ul>\n<p>对比起 AliNode 等前辈，Easy-Monitor 提供了：</p>\n<ul>\n<li>私有化部署能力。</li>\n<li>低侵入性，通过 Addon 的方式提供能力，无需定制 Node.js Runtime，能更快的跟进上游。</li>\n<li>支持 Linux、macOS、Windows 三大操作系统。</li>\n</ul>\n<p><img src=\"//static.cnodejs.org/FnEoTfjTCxChTFvTt_xIU8ko1Dnj\" alt=\"image.png\"></p>\n<ul>\n<li>文档地址：<a href=\"https://github.com/hyj1991/easy-monitor\">https://github.com/hyj1991/easy-monitor</a></li>\n<li>源码地址：<a href=\"https://github.com/X-Profiler\">https://github.com/X-Profiler</a></li>\n</ul>\n<h2>II. 整体架构</h2>\n<p>Easy-Monitor 经过了 1.x，2.x 两个大版本的功能迭代，目前的 3.0 版本是作者在 Node.js 监控侧的又一个阶段性总结，对这部分感兴趣的同学可以查看 <a href=\"https://www.yuque.com/hyj1991/easy-monitor/past-and-present\">前世今生</a>。</p>\n<p>目前实现了对 <strong>Window</strong>、<strong>Linux</strong> 和 <strong>MacOS</strong> 三大平台的 Node.js 应用监控支持，整体设计架构如下所示：</p>\n<p><img src=\"//static.cnodejs.org/FvZX-2V8QKJJKrIZHN17sbtKazI0\" alt=\"image.png\"></p>\n<p>控制台前端基于 <a href=\"https://vuejs.org/\">Vue.js</a> + <a href=\"https://github.com/view-design/ViewUI\">iView UI</a> 框架编写，监控服务端部分则是基于 <a href=\"https://eggjs.org/\">Egg.js</a> 框架编写，UI 部分整体参考了 AliNode 控制台。</p>\n<p>更多信息可以访问 <a href=\"https://www.yuque.com/hyj1991/easy-monitor/architecture\">用户手册 - 整体架构</a> 进行查看。</p>\n<p>在此，再次感谢 <a href=\"https://eggjs.org/\">Egg.js</a>、<a href=\"https://github.com/cnpm\">CNPM</a> 和 <a href=\"https://node.console.aliyun.com/\">AliNode</a> 对 Node.js 生态带来的贡献。</p>\n<h2>III. 部署指南</h2>\n<p>参照模块设计图，可以看到项目的部署主要分为两个部分：</p>\n<ul>\n<li>部署监控服务端</li>\n<li>Node.js 应用接入</li>\n</ul>\n<p>我们提供了以下 Demo 帮助大家快速体验下 Easy-Monitor 3.0 的能力。</p>\n<h3>控制台</h3>\n<p>大家可以访问 <a href=\"http://www.devtoolx.com/easy-monitor\">控制台 Demo</a> ，快速体验下新版。（Demo 在代码上做了一些特殊限制防止恶意操作，本地控制台部署参见下文 <a href=\"#AT5yW\">完整使用文档</a>）</p>\n<h3>应用接入</h3>\n<p>我们支持各种 Node.js 应用接入，此处以 <a href=\"https://eggjs.org/\">Egg.js</a> 为例：</p>\n<p>先安装插件：</p>\n<pre class=\"prettyprint language-bash\"><code>npm i --save egg-xtransit --xprofiler_binary_host_mirror=https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;xprofiler\n</code></pre><p>启用插件：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; {app_root}&#x2F;config&#x2F;plugin.js\nexports.xtransit = {\n  enable: true,\n  package: &#x27;egg-xtransit&#x27;,\n};\n</code></pre><p>配置接入信息：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; {app_root}&#x2F;config&#x2F;config.default.js\nexports.xtransit = {\n  server: &#x27;ws:&#x2F;&#x2F;devtoolx.com:7070&#x27;,\n  appId: 1,\n  appSecret: &#x27;f7b99d08cc0193106690860047b28970&#x27;\n};\n</code></pre><p>对应的 ID 需要访问 <a href=\"http://www.devtoolx.com/easy-monitor\">控制台 Demo</a> 来注册和获取，如下：</p>\n<p><img src=\"//static.cnodejs.org/FvG9ApruCc5ADFoXMLwh-ui77t17\" alt=\"image.png\"></p>\n<p>最后按照正常操作启动 Egg.js 项目即可，正常情况下，你可以在 <a href=\"http://www.devtoolx.com/easy-monitor\">控制台 Demo</a> 主页看到本地连接上来的实例：</p>\n<p><img src=\"//static.cnodejs.org/FtVey-27T8znhlQnbINeGp_zw048\" alt=\"image.png\"></p>\n<h3>用户手册</h3>\n<p>目前完整的使用文档部署在语雀上，参见 <a href=\"https://www.yuque.com/hyj1991/easy-monitor\">Easy-Monitor 3.0 用户手册</a>。</p>\n<p>开发者可以根据文档自行部署上述的监控服务端，再将自己的 Node.js 应用接入。</p>\n<h2>IV. 支持作者</h2>\n<p>最后的最后，作者是完全使用空余时间维护更新这个项目的，如果项目对你有帮助， 来个 <a href=\"https://github.com/hyj1991/easy-monitor\">star</a> 支持下作者吧 :)</p>\n<p>如果你在使用过程中有任何的疑问或者建议可以提 issue，或者扫码加钉钉群联系作者：</p>\n<p><img src=\"//static.cnodejs.org/FovdVuTHR8dqbNQA2G3WUX8dt93P\" alt=\"微信图片_20200717085956.jpg\"></p>\n<p>希望本项目如其名一样，能帮助开发者解决更多开发中遇到的问题，构建起对 Node.js 技术栈的信心，让 Node.js 更加 “简单”。</p>\n</div>",
		"title": "Easy-Monitor 3.0 开源 - 基于 Addon 的 Node.js 性能监控解决方案",
		"last_reply_at": "2020-09-26T03:04:44.884Z",
		"good": true,
		"top": true,
		"reply_count": 24,
		"visit_count": 69025,
		"create_at": "2020-06-11T08:42:43.597Z",
		"author": {
			"loginname": "hyj1991",
			"avatar_url": "https://avatars2.githubusercontent.com/u/19908330?v=4&s=120"
		}
	}, {
		"id": "5f7793bff9736b02ceadb32c",
		"author_id": "5ef7d6b5472c7975b04b7a13",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p><img src=\"https://lightyearvpn.com/assets/logo.png\" alt=\"光年vpn logo\"></p>\n<h1><a href=\"https://lightyearapp.me\">光年VPN - 科学上网， 翻墙利器</a></h1>\n<blockquote>\n<p>建议收藏此页面防止失联或者丢失</p>\n</blockquote>\n<ul>\n<li>部署SSR节点和V2Ray节点。</li>\n<li>无需配置，一键连接，适合小白。</li>\n<li>提供全球40多个节点，包括BGP线路和CN2 GIA线路。</li>\n<li>无限流量，流畅观看高清视频。</li>\n<li>海外专业团队运营。</li>\n<li>支持支付宝和PayPal，可7天内退款。</li>\n<li>注册后可免费VPN试用。</li>\n</ul>\n<blockquote>\n<p>官网提供免费SSR节点订阅链接，请访问<a href=\"https://lightyearapp.me/zh/free-vpn\">地址</a></p>\n</blockquote>\n<h2>官网链接</h2>\n<ul>\n<li><a href=\"https://lightyearapp.me\">最新免翻墙地址(2020/09/01更新)</a></li>\n<li><a href=\"https://lightyearvpn.com\">官方永久地址</a></li>\n</ul>\n<blockquote>\n<p>实时更新最新免翻墙地址!</p>\n</blockquote>\n<h2>应用下载</h2>\n<p>&lt;a target=&quot;_blank&quot; href=‘<a href=\"https://apps.apple.com/us/app/lightyearvpn-fast-trusted/id1495258888\">https://apps.apple.com/us/app/lightyearvpn-fast-trusted/id1495258888</a>’&gt;&lt;img width=“300” alt=‘Get it on Google Play’ src=‘<a href=\"https://applelaneanimalhospital.com/wp-content/uploads/2019/04/apple.png\">https://applelaneanimalhospital.com/wp-content/uploads/2019/04/apple.png</a>’/&gt;&lt;/a&gt;</p>\n<p>&lt;a target=&quot;_blank&quot; href=‘<a href=\"https://play.google.com/store/apps/details?id=com.stingsystemllc.lightyearapp\">https://play.google.com/store/apps/details?id=com.stingsystemllc.lightyearapp</a>’&gt;&lt;img width=“300” alt=‘Get it on Google Play’ src=‘<a href=\"https://applelaneanimalhospital.com/wp-content/uploads/2019/04/google.png\">https://applelaneanimalhospital.com/wp-content/uploads/2019/04/google.png</a>’/&gt;&lt;/a&gt;</p>\n<h2>网盘下载</h2>\n<p>如果Github下载速度不理想，可以使用网盘下载，支持Windows，Mac，和Android客户端下载。</p>\n<blockquote>\n<p><a href=\"https://lightyear.lanzous.com/b00tu4njg\">https://lightyear.lanzous.com/b00tu4njg</a></p>\n</blockquote>\n<h2>如何从海外的应用商店下载APP</h2>\n<blockquote>\n<p>&lt;a target=&quot;_blank&quot; href=“<a href=\"https://zhuanlan.zhihu.com/p/36574047\">https://zhuanlan.zhihu.com/p/36574047</a>”&gt;5分钟注册美国区Apple ID（2020测试有效）&lt;/a&gt;</p>\n</blockquote>\n<h2>电报群</h2>\n<blockquote>\n<p><a href=\"https://t.me/lightyearvpn\">https://t.me/lightyearvpn</a></p>\n</blockquote>\n</div>",
		"title": "光年VPN - 科学上网， 翻墙利器",
		"last_reply_at": "2020-10-26T08:16:09.301Z",
		"good": false,
		"top": false,
		"reply_count": 2,
		"visit_count": 371,
		"create_at": "2020-10-02T20:55:27.683Z",
		"author": {
			"loginname": "lightyearvpn",
			"avatar_url": "https://avatars0.githubusercontent.com/u/48337017?v=4&s=120"
		}
	}, {
		"id": "5f9637e7f9736b02ceadb62a",
		"author_id": "5540cab1208c44bf37c24e3c",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>灌水灌水\n</code></pre></div>",
		"title": "估计现在都没有人",
		"last_reply_at": "2020-10-26T02:43:51.454Z",
		"good": false,
		"top": false,
		"reply_count": 0,
		"visit_count": 21,
		"create_at": "2020-10-26T02:43:51.454Z",
		"author": {
			"loginname": "doxiaodong",
			"avatar_url": "https://avatars3.githubusercontent.com/u/6927481?v=4&s=120"
		}
	}, {
		"id": "5f8575a672af8c02d3f8e691",
		"author_id": "5875bd3d06fa6e2a4e4f730b",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>RT</p>\n</div>",
		"title": "域名被封了还有人么",
		"last_reply_at": "2020-10-25T15:51:50.822Z",
		"good": false,
		"top": false,
		"reply_count": 7,
		"visit_count": 226,
		"create_at": "2020-10-13T09:38:46.068Z",
		"author": {
			"loginname": "zy445566",
			"avatar_url": "https://avatars2.githubusercontent.com/u/14976489?v=4&s=120"
		}
	}, {
		"id": "5f8a622cf9736b02ceadb596",
		"author_id": "5b85221808d0b0fb2d8e6c84",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>大咖们，nodejs生态有没有比较成熟的微服务框架推荐？？</p>\n</div>",
		"title": "nodejs生态有没有比较成熟的微服务框架推荐？？",
		"last_reply_at": "2020-10-17T03:17:00.461Z",
		"good": false,
		"top": false,
		"reply_count": 0,
		"visit_count": 110,
		"create_at": "2020-10-17T03:17:00.461Z",
		"author": {
			"loginname": "danielmlc",
			"avatar_url": "https://avatars2.githubusercontent.com/u/16604995?v=4&s=120"
		}
	}, {
		"id": "5f79475972af8c02d3f8e513",
		"author_id": "59aa89ea9e95202d08c91ed3",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>落伍了哦：（\n<a href=\"https://github.com/github/fetch/blob/master/fetch.js.flow\">https://github.com/github/fetch/blob/master/fetch.js.flow</a>\n中的代码：</p>\n<pre class=\"prettyprint language-typescript\"><code>type RequestOptions = {|\n  body?: ?BodyInit;\n  credentials?: CredentialsType;\n  headers?: HeadersInit;\n  method?: string;\n  mode?: string;\n  referrer?: string;\n  signal?: ?AbortSignal;\n|}\n</code></pre><p>上面的类型定义{| ……|}什么用？\nbody?: ?BodyInit; 第二个问号又作何解</p>\n<p>谢谢</p>\n</div>",
		"title": ".js.flow后缀文件是typescript？还是facebook搞出来的？",
		"last_reply_at": "2020-10-10T01:32:34.961Z",
		"good": false,
		"top": false,
		"reply_count": 1,
		"visit_count": 243,
		"create_at": "2020-10-04T03:54:01.421Z",
		"author": {
			"loginname": "xinggsf",
			"avatar_url": "https://avatars3.githubusercontent.com/u/13033798?v=4&s=120"
		}
	}, {
		"id": "5f2138a6f0739b0e62d12b40",
		"author_id": "5a3075929807389a1809f330",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p><a href=\"https://yggx.net/\">妹子这舞蹈跳的好看，主要是人长得好看</a>\n<a href=\"http://yggx.net\">yggx.net</a></p>\n</div>",
		"title": "分享一个GIF图库 yggx.net",
		"last_reply_at": "2020-10-09T01:46:10.808Z",
		"good": false,
		"top": false,
		"reply_count": 1,
		"visit_count": 2633,
		"create_at": "2020-07-29T08:51:50.885Z",
		"author": {
			"loginname": "varscc",
			"avatar_url": "https://avatars3.githubusercontent.com/u/32264346?v=4&s=120"
		}
	}, {
		"id": "5f7c74e3f9736b02ceadb432",
		"author_id": "57c92f432adfc63a26784431",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>本站的dns解析挂了？</p>\n</div>",
		"title": "本站的dns解析挂了？",
		"last_reply_at": "2020-10-06T14:19:44.308Z",
		"good": false,
		"top": false,
		"reply_count": 3,
		"visit_count": 263,
		"create_at": "2020-10-06T13:45:07.675Z",
		"author": {
			"loginname": "Shonke",
			"avatar_url": "https://avatars.githubusercontent.com/u/9344384?v=3&s=120"
		}
	}, {
		"id": "5eeef3ea472c7975b04b69e3",
		"author_id": "5eeef33913f8b244e57cabc5",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p>项目地址: <a href=\"https://github.com/davanchen/easytype\">https://github.com/davanchen/easytype</a></p>\n<h1>欢迎使用EasyType：一个基于TypeScript的动态类型反射系统</h1>\n<p>众所周知JavaScript因为语言的特性，无法与JAVA一样提供一种动态类型反射机制，而市面上又缺乏完善的解决方案，EasyType的出现是为了从根本上解决这个问题, 赋予开发者尤其是后端开发者更多的能力。</p>\n<h6>警告：单元测试未完全覆盖，切勿用于商业项目。</h6>\n<h6>开源只是为了交流技术、不想把一个好的理念埋没在个人手里，由于个人时间关系，本项目可能不会得到良好的维护，期望有成熟的公司或者团队能够改进或者重构它，让他成为node后端必备框架之一。</h6>\n<h3>项目起源</h3>\n<p>从18年开始，我就决定让团队使用node+typescript来开发后端服务，经过一年多的实践，发现各种库都有一套自己的“建模语言”来申明类型，比如mongoose、数据验证器、GraphQL、GRPC、swagger等等。这不禁让我迷惑不解，为什么用了typescript以后还要重复写这么多的类型申明？于是我从19年初开始开发了这个框架陆续来实现。刚开始是通过AST来分析mongoose的schema生成模型接口和定义，但是没有从根本上解决问题，所以接下来是通过直接分析typescript的类申明来实现，后续又引入了json-schema标准，最后对枚举、方法、联合类型、泛型都提供了支持。</p>\n<h3>设计目标</h3>\n<ul>\n<li>能够覆盖typescript绝大多数的类型，尤其是对泛型能提供完善的支持。</li>\n<li>尽可能的减少侵入，无需改动任何的代码</li>\n<li>支持Transpile模式，无需构建即可直接运行，而且编译速度非常快</li>\n<li>能够通过cli运行与构建项目,也能够脱离cli运行或者构建项目</li>\n</ul>\n<h3>方案对比</h3>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>对比</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://github.com/gcanti/io-ts\" title=\"io-ts\">io-ts </a></td>\n<td>定义了一套类型声明，设计目标可能主要是解决IO传输中的编码与解码</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/typestack/class-transformer\" title=\"class-transformer\">class-transformer</a></td>\n<td>定义了一套修饰器，只支持部分的TS类型</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/YousefED/typescript-json-schema\" title=\"typescript-json-schema\">typescript-json-schema</a></td>\n<td>需要调用CLI生成JSON格式的类型声明，非动态</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/goloveychuk/tsruntime\" title=\"tsruntime\">tsruntime</a></td>\n<td>是和typescript-json-schema一样在TypeCheck阶段实现，因此不支持Transpile模式</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/andywer/type-reflect\" title=\"type-reflect\">type-reflect</a></td>\n<td>类似，但功能不够完善</td>\n</tr>\n</tbody>\n</table>\n<h3>使用场景</h3>\n<p>引入EasyType将为你的后端开发带来更大的想象空间，其中我们团队用到的部分就包括：</p>\n<ul>\n<li>不用添加任何代码，将TS类申明直接转换成mongoose schema</li>\n<li>不用添加任何代码，可以直接使用各种json-schema数据验证器</li>\n<li>不用添加任何代码，动态生成API文档，稍微改动就能生成OpenAPI规范的swagger文档，你的接口改动团队其他成员可以随时看到。</li>\n<li>不用添加任何代码，动态生成RPC声明，比如一键生成GRPC proto申明文件，把微服务开发变成一件很轻松的事情。</li>\n<li>由于后端能够输出完整的类型申明，因此前端（尤其是后台开发）能够快速的构建出数据显示、操作界面，会使开发变得更快速高效。</li>\n</ul>\n<h3>原理</h3>\n<p>通过typescript的自定义transform，在编译阶段把类型写入类描述中，最后在运行时生成json-schema标准的类型说明。</p>\n<pre class=\"prettyprint language-javascript\"><code>@Reflectable()\nexport class User extends Document {\n    &#x2F;** 用户ID *&#x2F;\n    uid: number;\n\n    &#x2F;** 用户名 *&#x2F;\n    username: string;\n}\n</code></pre><p>比如以上代码，通过编译器将变为:</p>\n<pre class=\"prettyprint language-javascript\"><code>export class User extends Document {\n    $easy.IsObject({\n        $type: 1,\n        $properties: {\n            uid: {\n                $type: 2,\n                $description: &quot;\\u7528\\u6237ID&quot;,\n                $ref: Number\n            },\n            username: {\n                $type: 2,\n                $description: &quot;\\u7528\\u6237\\u540D&quot;,\n                $ref: String\n            },\n        },\n        $target: User,\n        $id: &quot;User&quot;,\n        $extends: mongoose_1.Document\n    })\n    private $metadata: any;\n}\n</code></pre><p>通过在运行时调用 Schema.getMetadata(User), 即可得到User的类型声明(json-schema):</p>\n<pre class=\"prettyprint language-javascript\"><code>{\n    &quot;type&quot;: &quot;object&quot;,\n    &quot;properties&quot;: {\n        &quot;_id&quot;: {\n            &quot;type&quot;: &quot;string&quot;,\n            &quot;format&quot;: &quot;OBJECT_ID&quot;,\n            &quot;description&quot;: &quot;ID&quot;\n        },\n        &quot;uid&quot;: {\n            &quot;type&quot;: &quot;number&quot;,\n            &quot;description&quot;: &quot;用户ID&quot;,\n        },\n        &quot;username&quot;: {\n            &quot;type&quot;: &quot;string&quot;,\n            &quot;description&quot;: &quot;用户名&quot;,\n        }\n    },\n    &quot;required&quot;: [\n        &quot;_id&quot;,\n        &quot;uid&quot;,\n        &quot;username&quot;\n    ],\n    &quot;$id&quot;: &quot;User&quot;,\n    &quot;$x&quot;: &quot;Document&quot;\n}\n</code></pre><h3>更强大的ENUM</h3>\n<p>在typescript中enum的存在更像是为了描述类型（你在运行时很难分清哪个是key,哪个是value），这也就不能与JAVA一样提供一些操作, 因此EasyType在编译阶段增加一些方法，使之变得更加灵活和强大，借助这些特性我们就能够实现无缝输出ENUM信息到API文档，而无需再书写任何的注释或者代码。</p>\n<pre class=\"prettyprint language-javascript\"><code>export interface EnumInterface&lt;T&gt; {\n    readonly keys: string[];\n\n    readonly values: number[] | string[];\n\n    getValue(key: string): Undefinable&lt;T&gt;;\n\n    hasValue(value: any): boolean;\n\n    getKeys(value: any): string[];\n\n    getKey(value: any): Undefinable&lt;string&gt;;\n\n    hasKey(key: string): boolean;\n\n    getDescription(key: string): Undefinable&lt;string&gt;;\n}\n\nexport type Enum&lt;T = any, V = number | string&gt; =\n    { readonly [P in keyof T]: T[P]; }\n    &amp; Readonly&lt;EnumInfo&gt;\n    &amp; EnumInterface&lt;V&gt;\n    ;\n\n</code></pre><p>现在你可以通过 Enum&lt;Foo&gt;.Keys 和 Enum&lt;Bar&gt;.values 获得键值，也可以拿到对应的像这样的类型申明：</p>\n<pre class=\"prettyprint language-javascript\"><code>    {\n        &quot;name&quot;: &quot;AssetType&quot;,\n        &quot;description&quot;: &quot;用户资产类型&quot;,\n        &quot;fields&quot;: [\n            {\n                &quot;key&quot;: &quot;BALANCE&quot;,\n                &quot;value&quot;: 1,\n                &quot;description&quot;: &quot;账户余额&quot;\n            },\n            {\n                &quot;key&quot;: &quot;POINTS&quot;,\n                &quot;value&quot;: 3,\n                &quot;description&quot;: &quot;账户积分&quot;\n            }\n        ]\n    },\n</code></pre><h3>部分继承</h3>\n<p>使用关键词extends会继承基类所有的属性，有时候如果你想部分继承基类属性，可以使用Inherits语法糖：</p>\n<pre class=\"prettyprint language-javascript\"><code>@Reflectable()\nexport class UserLoginDto implements Inherits&lt;User&gt; {\n    username: string;\n    password: string;\n}\n\n</code></pre><h3>方法反射</h3>\n<p>方法的注释、修饰符、参数、返回值等信息会被标注到Metadata中，可以通过 Reflect.getMetadata(‘easy:metadata’, target, propertyKey) 获取。</p>\n<h3>还有哪些问题？</h3>\n<ul>\n<li>还没来得及做完整的单元测试，所以暂时不能用于商业项目</li>\n<li>泛型目前编译器这块已完成，但是运行时由于时间关系还未能提供支持</li>\n<li>由于设计原因，只能支持类的输出，不支持interface和type的输出，因为前者在js运行时以function存在，后者不存在于运行时，或许后面会想办法支持。</li>\n<li>低版本的TypeScript（3.7以下）会有一些问题，所以用最新的TSC编译吧。</li>\n</ul>\n<h3>插播一条广告</h3>\n<p>即将推出基于EasyType+nest.js的全家桶开发包，尽情期待。\n项目地址: <a href=\"https://github.com/davanchen/easynest\">https://github.com/davanchen/easynest</a></p>\n<h3>演示：借助vscode插件(即将开源)一键生成proto</h3>\n<p><img src=\"https://tmyx.oss-cn-hangzhou.aliyuncs.com/github/Code_7GLTwoRGAx.png\" alt>\n<img src=\"https://tmyx.oss-cn-hangzhou.aliyuncs.com/github/Code_oBYASf68Uo.png\" alt></p>\n<h3>演示：EasyNest API文档模块自动生成API描述（枚举、控制器、模型）</h3>\n<p><img src=\"https://tmyx.oss-cn-hangzhou.aliyuncs.com/github/screenshot_controller.PNG\" alt>\n<img src=\"https://tmyx.oss-cn-hangzhou.aliyuncs.com/github/screenshot_enums.PNG\" alt>\n<img src=\"https://tmyx.oss-cn-hangzhou.aliyuncs.com/github/screenshot_models.PNG\" alt></p>\n</div>",
		"title": "快来了解一下EasyType：开源的基于TypeScript的动态类型反射系统",
		"last_reply_at": "2020-10-03T06:40:33.596Z",
		"good": false,
		"top": false,
		"reply_count": 9,
		"visit_count": 4806,
		"create_at": "2020-06-21T05:45:14.647Z",
		"author": {
			"loginname": "davanchen",
			"avatar_url": "https://avatars2.githubusercontent.com/u/48879035?v=4&s=120"
		}
	}, {
		"id": "5ce36eb4518e0954fc41015b",
		"author_id": "5bc6779d37a6965f5905229a",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>各位前辈，之前有请教 ，使用权限管理框架，前辈介绍了casbin、shiro，请问有机会找到教学视频吗？付一些钱我也ok的，</p>\n<p>或是项目  的范例，谢谢</p>\n</div>",
		"title": "各位前辈，之前有请教 ，使用权限管理框架，前辈介绍了casbin、shiro，请问有机会找到教学视频吗？付一些钱我也ok的，谢谢",
		"last_reply_at": "2020-10-03T04:48:31.277Z",
		"good": false,
		"top": false,
		"reply_count": 9,
		"visit_count": 3420,
		"create_at": "2019-05-21T03:21:24.314Z",
		"author": {
			"loginname": "Solomonqoo",
			"avatar_url": "https://avatars3.githubusercontent.com/u/44214486?v=4&s=120"
		}
	}, {
		"id": "5f73ff3a72af8c02d3f8e1b1",
		"author_id": "5cc281d7a86ae80ce64b445a",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>现在egg多个进程间对资源的争抢是怎么设计这个锁的呢？目前我们自己都是使用redis.incr来争抢某个key，值为1的进程就可以操作该资源，其他进程放弃操作或者循环等待。\n看到有博客提到Atomics这个模块，不知道egg中是否可以使用这个实现锁？</p>\n</div>",
		"title": "egg多进程实现锁的最佳实践是什么？",
		"last_reply_at": "2020-10-03T01:10:09.580Z",
		"good": false,
		"top": false,
		"reply_count": 5,
		"visit_count": 394,
		"create_at": "2020-09-30T03:44:58.094Z",
		"author": {
			"loginname": "974806047",
			"avatar_url": "https://avatars3.githubusercontent.com/u/20623913?v=4&s=120"
		}
	}, {
		"id": "53487b01b9b1b4047b000fb8",
		"author_id": "51525d4a5dff253b3709382f",
		"content": "<div class=\"markdown-text\"><p>RT</p>\n</div>",
		"title": "Mongous 如何根据 _id 查询数据? 希望给个例子.",
		"last_reply_at": "2020-10-02T03:40:17.620Z",
		"good": false,
		"top": false,
		"reply_count": 6,
		"visit_count": 4194,
		"create_at": "2014-04-11T23:30:09.689Z",
		"author": {
			"loginname": "gabacai81",
			"avatar_url": "//gravatar.com/avatar/404dc6e8cf0755199b1381a5f2eeec0f?size=48"
		}
	}, {
		"id": "5f71af1af9736b02ceadaba5",
		"author_id": "5e13183c4bea432607fcd1d9",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p><strong>公司是一家tob的物联网车联网公司</strong>\n然后做saas软件  很多项目都是需要面对多个客户  每个客户的需求可能大致相同 有些细节或者流程会不同</p>\n<p><strong>困扰</strong>\n第一版出来之   后分开写的话 就需要维护很多个项目\n如果写到一个项目中的话 会变得很复杂 流程测试也很蛋疼 可能会改动其中一家的需求 影响到另一家的流程</p>\n<p>然后公司还有很多中台服务  比如 负责登陆的用户中心 负责认证的 负责数据的 还有业务的中台 等等一堆。。</p>\n<p>导致做项目的时候  即使需求不是很多 也会有很多人参与进来  一二十人都很正常 因为涉及的中台服务 岗位 很多　开发周期也很长</p>\n<p>感觉体验不是很好  QAQ</p>\n<p>个人感觉问题的所在就是如何“优雅”解决不同客户的需求的问题</p>\n<p>有没有有过这种经历的大佬　给点建议的QAQ</p>\n</div>",
		"title": "saas软件如何解决多客户需求",
		"last_reply_at": "2020-10-02T02:06:07.996Z",
		"good": false,
		"top": false,
		"reply_count": 8,
		"visit_count": 491,
		"create_at": "2020-09-28T09:38:34.482Z",
		"author": {
			"loginname": "zhsonga",
			"avatar_url": "https://avatars1.githubusercontent.com/u/18735806?v=4&s=120"
		}
	}, {
		"id": "5f70328972af8c02d3f8d919",
		"author_id": "5f703212f9736b02ceada86b",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>比如我给console.log 添加一个监听函数，每次执行log时，都会执行这个监听函数，不用改变console.log本身</p>\n</div>",
		"title": "请问大佬，node有没有办法给函数添加一个监听函数。",
		"last_reply_at": "2020-10-02T01:50:05.732Z",
		"good": false,
		"top": false,
		"reply_count": 4,
		"visit_count": 530,
		"create_at": "2020-09-27T06:34:49.874Z",
		"author": {
			"loginname": "soandsoprogrammer",
			"avatar_url": "https://avatars0.githubusercontent.com/u/38459469?v=4&s=120"
		}
	}, {
		"id": "5f6ff10472af8c02d3f8d7bf",
		"author_id": "5f6feff872af8c02d3f8d7b5",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>最近使用了koa-static 这个包，把服务器静态资源配置进去，访问的方法就是服务器地址加端口加文件名，但是发现配置多个文件都是直接加文件名称就可以访问了，请问路径如何细分呢？比如/business/xxxx.jpg ，谢谢啦</p>\n</div>",
		"title": "求问各位前辈，有用过Koa-static的吗？这个包如何细分各个路径呢？",
		"last_reply_at": "2020-10-02T01:48:47.852Z",
		"good": false,
		"top": false,
		"reply_count": 2,
		"visit_count": 1013,
		"create_at": "2020-09-27T01:55:16.588Z",
		"author": {
			"loginname": "RenXiaoTai",
			"avatar_url": "https://avatars0.githubusercontent.com/u/71952806?v=4&s=120"
		}
	}, {
		"id": "5f7576ae72af8c02d3f8e36d",
		"author_id": "5f75767472af8c02d3f8e36a",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><h2>下载地址：<a href=\"http://www.97yrbl.com/t-454.html\">百度网盘</a></h2>\n<p>第1章 课程介绍\n本章节介绍整个课程的内容，让大家了解课程的核心和安排。</p>\n<p>1-1 课程介绍（导学 ） 试看\n1-2 代码库和在线文档使用注意事项（必看）\n第2章 你好 Typescript： 进入类型的世界\n本章主要帮助大家理解 TypeScript 可以解决的问题和所带来的优势，带领大家学习 TS 中的各种基础类型，然后进阶到复杂类型，包括：Array, Tuple, interface, function, Class, Enum, Generices等，迅速帮助大家理解 TS 的基础使用方式和语法。</p>\n<p>2-1 什么是 Typescript\n2-2 为什么要学习 typescript\n2-3 安装 typescript\n2-4 原始数据类型和 Any 类型\n2-5 数组和元组\n2-6 Interface- 接口 初探\n2-7 函数\n2-8 类型推论 联合类型和 类型断言\n2-9 class - 类 初次见面\n2-10 类和接口 - 完美搭档\n2-11 枚举（Enum）\n2-12 泛型（Generics） 第一部分\n2-13 泛型（Generics） 第二部分 - 约束泛型\n2-14 泛型第三部分 - 泛型在类和接口中的使用\n2-15 类型别名，字面量 和 交叉类型\n2-16 声明文件\n2-17 内置类型\n第3章 初识 Vue3.0： 新特性详解\n首先浏览 vue3 新带来的变化，然后从为什么会有 vue3 引出话题， 带领大家学习 compostion API，自定义Hooks，Teleport，Suspense 和 全局 API 修改等一系列 vue3 的重大更新。</p>\n<p>3-1 vue3 新特性巡礼\n3-2 为什么会有 vue3\n3-3 使用 vue-cli 配置 vue3 开发环境\n3-4 项目文件结构分析和推荐插件安装\n3-5 vue3 - ref 的妙用 试看\n3-6 更近一步 - reactive\n3-7 vue3 响应式对象的新花样\n3-8 老瓶新酒 - 生命周期\n3-9 侦测变化 - watch\n3-10 vue3 模块化妙用- 鼠标追踪器\n3-11 模块化难度上升 - useURLLoader\n3-12 模块化结合typescript - 泛型改造\n3-13 Typescript 对 vue3 的加持\n3-14 Teleport - 瞬间移动 第一部分\n3-15 Teleport - 瞬间移动 第二部分\n3-16 Suspense - 异步请求好帮手第一部分\n3-17 Suspense - 异步请求好帮手第二部分\n3-18 全局 API 修改\n第4章 项目起航 - 准备工作和第一个页面\n本章从项目的需求开始分析，然后确定项目的整体结构和代码规范，并且为项目选择 Bootstrap 作为样式库，编写 ColumnList 和 GlobalHeader 完成简单的练手以后，开始挑战第一个比较复杂的 Dropdown 下拉菜单组件，最后还抽象抽象出第一个 hooks 函数。…</p>\n<p>4-1 项目起航 需求分析\n4-2 文件结构和代码规范\n4-3 样式解决方案简介和分析\n4-4 设计图拆分和组件属性分析\n4-5 ColumnList 组件编码\n4-6 ColumnList 组件使用 Bootstrap 美化\n4-7 GlobalHeader 组件编码\n4-8 Dropdown 组件基本功能编码\n4-9 Dropdown 组件添加 DropdownItem\n4-10 Dropdown 组件点击外部区域自动隐藏\n4-11 useClickOutside 第一个自定义函数\n第5章 表单的世界 - 完成自定义 Form 组件\n本章来到表单的世界，从头到尾非常完整的完成了一个带验证表单组件的全流程开发过程，在整个过程中，我们还学习到了 v-model，$attrs, slot，组件父子通讯 和 mitt 的各种知识点。</p>\n<p>5-1 web 世界的经典元素 - 表单\n5-2 ValidateInput 第一部分 — 简单的实现 试看\n5-3 ValidateInput 第二部分 —抽象验证规则\n5-4 ValidateInput 第三部分 — 支持 v-model\n5-5 ValidateInput 编码第四部分 — 使用 $attrs 支持默认属性\n5-6 ValidateForm 组件需求分析\n5-7 ValidateForm 编码第一部分 - 使用插槽 slot\n5-8 ValidateForm 编码第二部分 - 尝试父子通讯\n5-9 ValidateForm 编码第三部分 - 寻找外援 mitt\n5-10 ValidateForm 编码第四部分 - 大功告成\n第6章 请你吃全家桶 - 初步使用 vue-router 和 vuex\n本章从 SPA 的概念引出，完成了 vue-router 的安装，然后学习它的基本使用，获取信息，动态跳转，前置守卫和元信息等各种知识点，然后又介绍了状态管理工具的具体定义，从而引出 vuex 的安装 和 它的 state，mutation，getter 等多个基本知识点。…</p>\n<p>6-1 什么是 SPA（Single Page Application） 应用？\n6-2 vue-router 安装和使用\n6-3 vue-router 配置路由\n6-4 vue-router 添加路由\n6-5 添加 columnDetail页面\n6-6 状态管理工具是什么\n6-7 Vuex 简介和安装\n6-8 Vuex 整合当前应用\n6-9 使用 Vuex getters\n6-10 添加新建文章页面\n6-11 Vue router 添加路由守卫 - 前置守卫\n6-12 Vue router 添加路由守卫 - 使用元信息完成权限管理\n第7章 前后端结合 - 项目整合后端接口\n本章从 前后端分离和 RESTful 概念入手，介绍了为学生提供的 swagger 调试工具如何使用，然后引入 axios，通过 vuex action 的添加，实现 async 改造 和 axios 拦截器的基本用法，最后还抽象出一个 Loader 组件的编码和实现过程。</p>\n<p>7-1 前后端分离开发是什么\n7-2 RESTful API 设计理念\n7-3 使用 swagger在线文档查看接口详情\n7-4 axios 的基本用法和独家后端API 使用（必看）\n7-5 使用vuex action 发送异步请求\n7-6 使用vuex action 发送异步请求第二部分\n7-7 使用 async 和 await 改造异步请求\n7-8 使用axios拦截器添加loading效果\n7-9 Loader 组件编码第一部分 - 基本实现\n7-10 Loader 组件编码第二部分 - 使用 Teleport 进行改造\n第8章 通行凭证 - 权限管理\n本章从 获取 token 为起点，讲述了 JWT 通用身份验证工具的原理和实现，然后完成了 axios 设置通用header 和 持久化登录的处理方法，之后还添加了全局通用错误处理，最后抽象出一个通用组件 Message 的编码和实现过程。</p>\n<p>8-1 登录第一部分 获取token\n8-2 jwt 的运行机制\n8-3 登录第二部分 axios 设置通用 header\n8-4 登录第三部分 持久化登录状态\n8-5 通用错误处理\n8-6 创建 Message 组件\n8-7 Message 组件改进为函数调用形式\n8-8 作业：注册页面的编写\n第9章 道高一尺 - 上传组件\n本章实现了 Upload 组件从分析，编码的全过程，在这个过程中，我们将会学到：上传文件的原理，使用 axios 完成文件上传的方法，循序渐进的完成一个复杂组件的开发流程。</p>\n<p>第10章 最终的功能 - 编辑和删除文章\n通过完成文章的编辑和删除功能，引出了之前组件留下的几个 bug，通过解决bug 带给大家持续优化的思路和方案，最后完成了一个通用 Modal 组件的编码过程。</p>\n<p>第11章 持续优化\n通过分析发现应用中可以优化的两个部分，提出并编码 数组改成对象 的store 优化方案以及防止重复请求的解决方案。最后还抽象除了 useLoadMore 的逻辑实现，最终完成了一个复杂的自定义 Hooks。</p>\n<p>第12章 项目构建和部署\n从生产环境的概念以及生产环境和开发环境的异同的概念开始，接着实践了应用构建，构建代码上线，和构建代码持续集成的一系列概念。</p>\n<p>第13章 课程总结\n本章节带领大家回顾课程的内容。</p>\n<p>本课程持续更新中</p>\n</div>",
		"title": "Vue3.0（正式版） + TS 仿知乎专栏企业级项目",
		"last_reply_at": "2020-10-01T06:26:54.078Z",
		"good": false,
		"top": false,
		"reply_count": 0,
		"visit_count": 375,
		"create_at": "2020-10-01T06:26:54.078Z",
		"author": {
			"loginname": "huashanjiaoxia",
			"avatar_url": "https://avatars1.githubusercontent.com/u/72186899?v=4&s=120"
		}
	}, {
		"id": "5f70776b72af8c02d3f8d9b2",
		"author_id": "51b44498f78196a85c3f28b7",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>在项目开发中遇到了使用第三方旧库，仅提供回调方式返回结果。现在遇到的问题是：</p>\n<pre class=\"prettyprint\"><code>MyController{\n\tasync fn(){\n\t\tconst ctx = this.ctx;\n\t\t&#x2F;&#x2F;调用第三方库\n\t\tapi(&#x27;balabala&#x27;,function(err,cb){\n\t\t\tif(xxx){\n\t\t\t}\n\t\t\tctx.body=&quot;success&quot;; &#x2F;&#x2F;前端请求到此Fn时，无返回数据.\n\t\t})\n\t}\n}\n</code></pre><p>请问如何正确使用this.ctx，才能让Controller正确响应请求.</p>\n</div>",
		"title": "Egg,Controller中回调函数问题",
		"last_reply_at": "2020-09-30T11:27:06.332Z",
		"good": false,
		"top": false,
		"reply_count": 6,
		"visit_count": 691,
		"create_at": "2020-09-27T11:28:43.385Z",
		"author": {
			"loginname": "nobody",
			"avatar_url": "https://avatars1.githubusercontent.com/u/12067939?v=4&s=120"
		}
	}, {
		"id": "5f74341372af8c02d3f8e21f",
		"author_id": "5b51454afb9e84ec69cc1c43",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p>马上要国庆节了，做了这个npm-dist，取名随意\n移除node_modules无用文件，很多npm包加了很多小包，个人觉得不妥，特想精简一下，打包环境适用\n<a href=\"https://www.npmjs.com/package/npm-dist/v/1.0.1\">https://www.npmjs.com/package/npm-dist/v/1.0.1</a>\n今年以来，有感这个论坛及node圈热度不在，有意见和建议欢迎反馈，大家共勉</p>\n</div>",
		"title": "npm-dist，提取node_modules有用文件",
		"last_reply_at": "2020-09-30T07:30:27.334Z",
		"good": false,
		"top": false,
		"reply_count": 0,
		"visit_count": 276,
		"create_at": "2020-09-30T07:30:27.334Z",
		"author": {
			"loginname": "index-js",
			"avatar_url": "https://avatars0.githubusercontent.com/u/26304725?v=4&s=120"
		}
	}, {
		"id": "5f6c8775f9736b02ceada2e2",
		"author_id": "575eaa97c1518403160a45c4",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><h1>文件句柄泄露导致的进程假死</h1>\n<p>开源的 Node.js 性能监控与线上故障定位工具，欢迎大家关注：<a href=\"https://github.com/hyj1991/easy-monitor\">https://github.com/hyj1991/easy-monitor</a></p>\n<p>好久没写 Node.js 故障案例了，今天是一枚全新的进程假死无响应案例。</p>\n<p>特点时完全不同于之前常规遇到的类死循环引发的阻塞假死，值得记录分析的过程，希望对遇到其它的类似案例的开发者有所启发。</p>\n<h2>I. 故障现象</h2>\n<p><a href=\"https://github.com/hyj1991/easy-monitor\">Easy-Monitor</a> 开源官方讨论群里有一位同学 Midqiu 遇到了进程跑几个小时后就处于假死无响应的问题，而且神奇的是进程假死的同时，监控服务端的 **系统数据 **也同时断开：</p>\n<p><img src=\"//static.cnodejs.org/FiT1nb8NZx4pZH5F5gWCwo8uAw2_\" alt=\"image.png\"></p>\n<p>此时 <strong>进程数据</strong> 界面则回退到实例刚刚接入还未上报数据的状态：</p>\n<p><img src=\"//static.cnodejs.org/Fk7SFMwrpMtP8pQyAAVqepjFiYJh\" alt=\"image.png\"></p>\n<p>可以看到业务进程依旧在，检查此进程状态则显示 <code>xprofiler</code> 插件未启用：</p>\n<p><img src=\"//static.cnodejs.org/FrM08gctSqTkqWXyM419wnR_auMZ\" alt=\"image.png\"></p>\n<p>可以确认这个进程在几个小时之前是正确接入了 Easy-Monitor 的监控服务端的，经过和 Midqiu 的沟通，发现从进程假死的那一刻开始， <code>xprofiler</code> 插件的日志就没有再生成了。</p>\n<p>但是 <code>xprofiler</code> 插件在设计之初为了规避和 JS 工作主线程之间的互相干扰，所以是采用了 <code>uv trhread</code> 起了工作线程处理内核数据的，理论上 JS 线程卡死也不会影响它的内核日志输出。</p>\n<p>这样现象就很奇怪了，Node.js 的 JS 主线程卡死竟然会让插件的日志也无法正常输出。</p>\n<h2>II. 初步排查问题</h2>\n<p>既然是进程假死无响应，首先猜测的就是是不是 JS 工作主线程卡死导致的，所以线下沟通 SSH 到服务器上查看假死时的 Node.js 负载：</p>\n<p><img src=\"//static.cnodejs.org/Fnyk3J1fLfJXw-HbxFSMk-vEfYEs\" alt=\"image.png\"></p>\n<p>使用 <code>top -H -p &lt;pid&gt;</code> 查看发现 CPU 占用不到 1%，内存整体在 300MB 附近也非常正常。这时候其实我还不死心，手动在服务器应用下执行了 <code>xprofiler</code> 插件的命令：</p>\n<pre class=\"prettyprint language-bash\"><code>.&#x2F;node_modules&#x2F;.bin&#x2F;xprofctl check_version -p &lt;pid&gt;\n</code></pre><p>然而事实证明确实不仅仅是 JS 主线程假死，连插件创建的 IPC 通信线程也假死了：</p>\n<p><img src=\"//static.cnodejs.org/Fq_n-8Qmwfekrq1ikItZCp_S9VJZ\" alt=\"image.png\"></p>\n<p>此时第一次感到这个问题可能没有想象的那么简单了，初步总结了下故障现象：</p>\n<ul>\n<li>运行几小时后 Node.js 服务无响应，进程还在（未重启）</li>\n<li>进程的 CPU 和 RSS 均正常</li>\n<li><code>xprofiler</code> 插件创建的内核日志子线程和 IPC 通信子线程也无响应</li>\n</ul>\n<p>此时没什么好办法，只能祭出大招手动生成分析 Core 文件。</p>\n<h2>III. 分析 Coredump</h2>\n<p>首先在服务器上安装神器 <code>gcore</code>，然后执行 <code>sudo gcore &lt;pid&gt;</code> 生成 core 文件。Midqiu 将生成的 core 文件和 node 可执行文件打包发给了我，本地使用 GDB 进行分析：</p>\n<pre class=\"prettyprint language-bash\"><code> gdb .&#x2F;node core.24269\n For help, type &quot;help&quot;.\nType &quot;apropos word&quot; to search for commands related to &quot;word&quot;...\nReading symbols from .&#x2F;node...done.\nwarning: .dynamic section for &quot;&#x2F;lib64&#x2F;ld-linux-x86-64.so.2&quot; is not at the expected address (wrong library or version mismatch?)\nwarning: Could not load shared library symbols for 7 libraries, e.g. &#x2F;lib64&#x2F;libdl.so.2.\nUse the &quot;info sharedlibrary&quot; command to see the complete listing.\nDo you need &quot;set solib-search-path&quot; or &quot;set sysroot&quot;?\nCore was generated by &#96;node&#x27;.\n#0  0x00007f2e584a6483 in ?? ()\n[Current thread is 1 (LWP 24270)]\n(gdb) bt\n#0  0x00007f2e584a6483 in ?? ()\n#1  0x0000000000000000 in ?? ()\n</code></pre><p>好家伙全是乱码，这里显然缺少运行时的动态链接库，将服务器上的动态链接库打包后手动指定根目录：</p>\n<pre class=\"prettyprint language-bash\"><code>(gdb) set sysroot &#x2F;home&#x2F;hyj1991&#x2F;git&#x2F;examples&#x2F;0924&#x2F;libs\nReading symbols from &#x2F;home&#x2F;hyj1991&#x2F;git&#x2F;examples&#x2F;0924&#x2F;libs&#x2F;lib64&#x2F;libdl.so.2...(no debugging symbols found)...done.\nReading symbols from &#x2F;home&#x2F;hyj1991&#x2F;git&#x2F;examples&#x2F;0924&#x2F;libs&#x2F;lib64&#x2F;libstdc++.so.6...(no debugging symbols found)...done.\nReading symbols from &#x2F;home&#x2F;hyj1991&#x2F;git&#x2F;examples&#x2F;0924&#x2F;libs&#x2F;lib64&#x2F;libm.so.6...(no debugging symbols found)...done.\nReading symbols from &#x2F;home&#x2F;hyj1991&#x2F;git&#x2F;examples&#x2F;0924&#x2F;libs&#x2F;lib64&#x2F;libgcc_s.so.1...(no debugging symbols found)...done.\nReading symbols from &#x2F;home&#x2F;hyj1991&#x2F;git&#x2F;examples&#x2F;0924&#x2F;libs&#x2F;lib64&#x2F;libpthread.so.0...(no debugging symbols found)...done.\nwarning: Unable to find libthread_db matching inferior&#x27;s thread library, thread debugging will not be available.\nReading symbols from &#x2F;home&#x2F;hyj1991&#x2F;git&#x2F;examples&#x2F;0924&#x2F;libs&#x2F;lib64&#x2F;libc.so.6...(no debugging symbols found)...done.\nReading symbols from &#x2F;home&#x2F;hyj1991&#x2F;git&#x2F;examples&#x2F;0924&#x2F;libs&#x2F;home&#x2F;work&#x2F;node&#x2F;node_modules&#x2F;xprofiler&#x2F;build&#x2F;binding&#x2F;Release&#x2F;node-v72-linux-x64&#x2F;xprofiler.node...(no debugging symbols found)...done.\n</code></pre><p>这样总算可以正常查看每一个线程的栈帧回溯：</p>\n<pre class=\"prettyprint language-bash\"><code>(gdb) thread apply all bt\nThread 13 (LWP 24269):\n#0  0x00007f2e584a6483 in epoll_wait () from &#x2F;home&#x2F;hyj1991&#x2F;git&#x2F;examples&#x2F;0924&#x2F;libs&#x2F;lib64&#x2F;libc.so.6\n#1  0x00000000013480e0 in uv__io_poll (loop=loop@entry=0x2c9aac0 &lt;default_loop_struct&gt;, timeout=5526) at ..&#x2F;deps&#x2F;uv&#x2F;src&#x2F;unix&#x2F;linux-core.c:309\n#2  0x0000000001335ddf in uv_run (loop=0x2c9aac0 &lt;default_loop_struct&gt;, mode=UV_RUN_DEFAULT) at ..&#x2F;deps&#x2F;uv&#x2F;src&#x2F;unix&#x2F;core.c:381\n#3  0x0000000000a4b5f5 in node::NodeMainInstance::Run() ()\n#4  0x00000000009da5a8 in node::Start(int, char**) ()\n#5  0x00007f2e583ca3d5 in __libc_start_main () from &#x2F;home&#x2F;hyj1991&#x2F;git&#x2F;examples&#x2F;0924&#x2F;libs&#x2F;lib64&#x2F;libc.so.6\n#6  0x0000000000979215 in _start ()\n\nThread 8 (LWP 24285):\n#0  0x00007f2e5846ce2d in nanosleep () from &#x2F;home&#x2F;hyj1991&#x2F;git&#x2F;examples&#x2F;0924&#x2F;libs&#x2F;lib64&#x2F;libc.so.6\n#1  0x00007f2e5846ccc4 in sleep () from &#x2F;home&#x2F;hyj1991&#x2F;git&#x2F;examples&#x2F;0924&#x2F;libs&#x2F;lib64&#x2F;libc.so.6\n#2  0x00007f2e559809c8 in xprofiler::CreateIpcServer(void (*)(char*)) () from &#x2F;home&#x2F;hyj1991&#x2F;git&#x2F;examples&#x2F;0924&#x2F;libs&#x2F;home&#x2F;work&#x2F;node&#x2F;node_modules&#x2F;xprofiler&#x2F;build&#x2F;binding&#x2F;Release&#x2F;node-v72-linux-x64&#x2F;xprofiler.node\n#3  0x00007f2e5877cdd5 in start_thread () from &#x2F;home&#x2F;hyj1991&#x2F;git&#x2F;examples&#x2F;0924&#x2F;libs&#x2F;lib64&#x2F;libpthread.so.0\n#4  0x00007f2e584a5ead in clone () from &#x2F;home&#x2F;hyj1991&#x2F;git&#x2F;examples&#x2F;0924&#x2F;libs&#x2F;lib64&#x2F;libc.so.6\n\nThread 7 (LWP 24284):\n#0  0x00007f2e5846ce2d in nanosleep () from &#x2F;home&#x2F;hyj1991&#x2F;git&#x2F;examples&#x2F;0924&#x2F;libs&#x2F;lib64&#x2F;libc.so.6\n#1  0x00007f2e5846ccc4 in sleep () from &#x2F;home&#x2F;hyj1991&#x2F;git&#x2F;examples&#x2F;0924&#x2F;libs&#x2F;lib64&#x2F;libc.so.6\n#2  0x00007f2e559409b4 in xprofiler::CreateLogThread(void*) () from &#x2F;home&#x2F;hyj1991&#x2F;git&#x2F;examples&#x2F;0924&#x2F;libs&#x2F;home&#x2F;work&#x2F;node&#x2F;node_modules&#x2F;xprofiler&#x2F;build&#x2F;binding&#x2F;Release&#x2F;node-v72-linux-x64&#x2F;xprofiler.node\n#3  0x00007f2e5877cdd5 in start_thread () from &#x2F;home&#x2F;hyj1991&#x2F;git&#x2F;examples&#x2F;0924&#x2F;libs&#x2F;lib64&#x2F;libpthread.so.0\n#4  0x00007f2e584a5ead in clone () from &#x2F;home&#x2F;hyj1991&#x2F;git&#x2F;examples&#x2F;0924&#x2F;libs&#x2F;lib64&#x2F;libc.so.6\n</code></pre><p>可以看到 <code>xprofiler</code> 插件创建的两个线程正常工作，JS 主线程则处于 <code>epoll_wait</code> 状态，没有任何可疑的会导致进程假死的阻塞！</p>\n<p>到这里我是真的疑惑了，线程堆栈完全正常，CPU 和内存也正常，那么进程为什么会处于无响应的假死状态呢？</p>\n<h2>IV. 另一个思路</h2>\n<p>连万能的 Core 分析都找不到异常的地方，似乎这个问题已经没办法排查了。</p>\n<p>无奈之下，我又回到一开始的问题： <strong>为什么处于子线程的 xprofiler 插件不再输出日志</strong></p>\n<p>回顾了一遍 <code>xprofiler</code> 插件中定时采集输出日志的逻辑：</p>\n<pre class=\"prettyprint language-cpp\"><code>static void CreateLogThread(void *unused) {\n  uint64_t last_loop_time = uv_hrtime();\n  while (1) {\n    Sleep(1);\n\n    SetNowCpuUsage();\n\n    if (uv_hrtime() - last_loop_time &gt;= GetLogInterval() * 10e8) {\n      last_loop_time = uv_hrtime();\n      bool log_format_alinode = GetFormatAsAlinode();\n\n      GetMemoryInfo();\n      GetLibuvHandles();\n\n      Sleep(1);\n\n      WriteCpuUsageInPeriod(log_format_alinode);\n      WriteMemoryInfoToLog(log_format_alinode);\n      WriteGcStatusToLog(log_format_alinode);\n      WriteLibuvHandleInfoToLog(log_format_alinode);\n      WriteHttpStatus(log_format_alinode, GetPatchHttpTimeout());\n    }\n  }\n}\n</code></pre><p>可以确定只要日志线程依旧存活，一定会走到写日志的逻辑：</p>\n<pre class=\"prettyprint language-cpp\"><code>#define WRITET_TO_FILE(type)                   \\\n  uv_mutex_lock(&amp;logger_mutex);                \\\n  type##_stream.open(filepath, std::ios::app); \\\n  type##_stream &lt;&lt; log;                        \\\n  type##_stream.close();                       \\\n  uv_mutex_unlock(&amp;logger_mutex);\n</code></pre><p>这里用了一个宏来将日志写到文件，本质上就是一个 <code>ofstream</code> 的文件流，看到这里我有一个猜测是不是这个文件流打开失败了导致内核日志没有正常写入文件。</p>\n<p>于是去翻 <a href=\"https://linux.die.net/man/2/open\">Linux Man 手册 open 方法</a> 看看哪些情况下会调用失败：</p>\n<p><img src=\"//static.cnodejs.org/FsHU0ANT9qcpgRt85ATemYL7IKs3\" alt=\"image.png\"></p>\n<p>其它的看起来都不太可能，唯独和文件打开数相关的限制看起来可疑：</p>\n<blockquote>\n<p>The system limit on the total number of open files has been reached.</p>\n</blockquote>\n<p>到这里感觉突然峰回路转，立马联系 Midqiu 查看重启后的进程的文件打开数：</p>\n<pre class=\"prettyprint language-bash\"><code>lsof -p &lt;pid&gt; | wc -l\n</code></pre><p>并且将这个值与系统的 <code>ulimit -n</code> 限制进行对比：</p>\n<p><img src=\"//static.cnodejs.org/Fiox3HhSoTVejnzqBD7RF-A8m6yX\" alt=\"image.png\"></p>\n<p>果然，重启后的 Node.js 进程文件打开数随着访问量逐步上涨，逐渐逼近系统的限制，问题就是出在这个假死进程的文件打开数上！</p>\n<h2>V. 定位问题代码段</h2>\n<p>有了问题的方向接下来就方便很多，我们可以使用 <code>lsof -p &lt;pid&gt;</code> 查看具体是哪些句柄：</p>\n<p><img src=\"//static.cnodejs.org/FrmkQz52RaDaTEt3xk-OjKaxsjpk\" alt=\"image.png\"></p>\n<p>好家伙，8W+ 的 <strong>/home/work/node/logs/important/production.x-access.serverless_runtime.2020-09-24.log</strong> 这个文件的重复文件句柄！</p>\n<p>经过沟通，这个文件是项目里面用来记录用户请求 access 日志对应的日志文件，那么猜测是记录 access 日志的中间件在重复的 <code>fs.open</code> 此文件。</p>\n<p>拿到这个日志中间件的源代码，果然存在一个 <code>Logger</code> 类里有 <code>fs.open</code> 动作：</p>\n<pre class=\"prettyprint language-javascript\"><code>private async ensureFile(filename: string): Promise &lt; number &gt; {\n  if(Object.keys(this.fds).length &gt; 150) {\n    for (const [_, fd] of Object.entries(this.fds)) {\n      fs.close(fd);\n    }\n    this.fds = {};\n   }\n  if (!this.fds[filename]) {\n    this.fds[filename] = await new Promise&lt;number&gt;((resolve, reject) =&gt; {\n      fs.open(filename, &quot;a&quot;, (err, fd) =&gt; {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(fd);\n        }\n      });\n    });\n  }\n  return this.fds[filename];\n}\n</code></pre><p>然后是记录日志的地方会调用这个方法获取日志文件的 fd：</p>\n<pre class=\"prettyprint language-javascript\"><code>private async appendLine(filename: string, line: string): Promise &lt; void&gt; {\n  const fd = await this.ensureFile(filename);\n  await new Promise(((resolve, reject) =&gt; {\n    fs.write(fd, line + &quot;\\n&quot;, (err) =&gt; {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  }));\n}\n</code></pre><p>这个 <code>Logger</code> 类到这里看起来也没问题，然而最后回到服务的入口文件时发现开发者竟然把 <code>Logger</code> 这个需要全局共享的实例初始化放到了 Express 中间件里：</p>\n<pre class=\"prettyprint language-javascript\"><code>app.use(function(req, res, next) {\n  &#x2F;&#x2F;...\n  const logger = new Logger();\n  res.locals.log = logger;\n  next();\n});\n</code></pre><p>这就导致每来一个用户请求都会实例化一个 <code>Logger</code> 实例，此时记录本次请求的 access 日志就会打开一个重复的日志文件句柄，从而导致了进程文件句柄的泄露。</p>\n<p>最后进程可使用的文件句柄数超过系统限制后进程就处于假死状态，表现为文件句柄数溢出后，后续此进程任何 I/O 相关的系统调用都会阻塞。</p>\n<h2>VI. 修复文件句柄泄露</h2>\n<p>定位到代码问题后，修复也非常简单，这里可以全局初始化 access 日志实例，请求日志共享此文件句柄即可。</p>\n<p>另外简单点也可以直接修改 <code>appendLine</code> 方法为 <code>fs.writeFile</code> ：</p>\n<pre class=\"prettyprint language-javascript\"><code>private async appendLine(filename: string, line: string): Promise &lt; void&gt; {\n  await new Promise(((resolve, reject) =&gt; {\n    fs.writeFile(filename, line + &quot;\\n&quot;, { flag: &#x27;a&#x27; }, (err) =&gt; {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  }));\n}\n</code></pre><p>这样牺牲了一部分性能但是不会有文件句柄泄露的问题。</p>\n<h2>VII. 小结</h2>\n<p>实际上 Node.js 提供的的 <code>stream</code> 、 <code>net</code> 以及 <code>fs</code> 里面的 fd 相关操作函数，这些模块或者函数相对 Node.js 其它封装的上层函数更接近底层库。</p>\n<p>而历史经验告诉我们，这部分底层库相关的函数，如果自己没有完全理解千万不要随便想当然的用，大概率一写一个大坑等着你。</p>\n<p>最后 Easy-Monitor 即将加入对监控进程自身的文件打开数的监控，帮助大家下次秒解决此类问题。</p>\n</div>",
		"title": "Node 案发现场揭秘 —— 文件句柄泄露导致进程假死",
		"last_reply_at": "2020-09-30T02:39:46.709Z",
		"good": true,
		"top": false,
		"reply_count": 17,
		"visit_count": 948,
		"create_at": "2020-09-24T11:48:05.149Z",
		"author": {
			"loginname": "hyj1991",
			"avatar_url": "https://avatars2.githubusercontent.com/u/19908330?v=4&s=120"
		}
	}, {
		"id": "5f73523072af8c02d3f8e057",
		"author_id": "59a50205bc6d953708128944",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p><a href=\"https://podcasts.apple.com/cn/podcast/%E5%88%9B%E4%B8%9A%E5%86%85%E5%B9%95-startup-insider/id1448032419?i=1000492432113\">关明生回忆2001：阿里巴巴的背水一战</a>\n客户第一，这个和目前公司是一样的。\n谁都喜欢赢，公司同样需要赢得市场。</p>\n</div>",
		"title": "提前两天就休假了，正好晚上听 《创业内幕 Startup Insider》播客有感。",
		"last_reply_at": "2020-09-29T15:26:40.078Z",
		"good": false,
		"top": false,
		"reply_count": 0,
		"visit_count": 364,
		"create_at": "2020-09-29T15:26:40.078Z",
		"author": {
			"loginname": "jxycbjhc",
			"avatar_url": "https://avatars0.githubusercontent.com/u/16661897?v=4&s=120"
		}
	}, {
		"id": "5f65f8acc1c67a7dd9aff375",
		"author_id": "56a36ee4cf60b1b94bab33fc",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p>分享一个刚刚通过审核的小程序，整合了cnodejs和v2ex 二个社区的资源，欢迎各位大侠指教。</p>\n<p><img src=\"//static.cnodejs.org/Fm1m29s7VPGdc69TvQ5LnHZ0VcZe\" alt=\"WechatIMG1.jpeg\"></p>\n</div>",
		"title": "再造二个轮子，整合cnodejs和v2ex的第3方小程序",
		"last_reply_at": "2020-09-28T11:58:30.030Z",
		"good": false,
		"top": false,
		"reply_count": 2,
		"visit_count": 5172,
		"create_at": "2020-09-19T12:25:16.797Z",
		"author": {
			"loginname": "yyseek",
			"avatar_url": "https://avatars3.githubusercontent.com/u/16741215?v=4&s=120"
		}
	}, {
		"id": "5f716f1d72af8c02d3f8dbac",
		"author_id": "5de8d0a4484806122a97d956",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>场景：\n安卓客户端请求苹果登陆认证会跳转浏览器进行认证，完成认证后会重定向至服务端（eggjs），然后服务端完成逻辑（生成token）后需要能够跳回安卓客户端。\n问题：\n我在一个第三方库提供的例子中，它使用的是express进行服务端的逻辑处理，最后使用</p>\n<pre class=\"prettyprint language-js\"><code>  \tconst url = &#96;intent:&#x2F;&#x2F;callback?#Intent;package=PACKAGE;scheme=signinwithapple;end&#96;;\n  \tresponse.redirect(307, url);\n</code></pre><p>进行重定向回来客户端成功了。\n但是在eggjs中我使用类似的重定向方法：</p>\n<pre class=\"prettyprint language-js\"><code>    const url = &#x27;intent:&#x2F;&#x2F;callback?#Intent;package=PACKAGE;scheme=signinwithapple;end&#x27;;\n    ctx.status = 307;\n    ctx.redirect(url);\n</code></pre><p>却是报404；</p>\n<p>然后我调断点进入egg的redirect方法，发现它会因为我url变量中协议（protocal）写的是intent不是http/https而把url重置为&quot;/&quot;，最后跑进了unsafeRedirect()。但我不知道是不是因为这个原因而导致的重定向失败。</p>\n<p>所以我想知道，<strong>egg中有能够重定向回安卓客户端的方法吗？</strong></p>\n</div>",
		"title": "eggjs中能够重定向返回（打开）安卓应用吗？",
		"last_reply_at": "2020-09-28T06:29:40.118Z",
		"good": false,
		"top": false,
		"reply_count": 2,
		"visit_count": 358,
		"create_at": "2020-09-28T05:05:33.456Z",
		"author": {
			"loginname": "yao17",
			"avatar_url": "https://avatars3.githubusercontent.com/u/18514854?v=4&s=120"
		}
	}, {
		"id": "5f71724d72af8c02d3f8dbb1",
		"author_id": "52e63d3b78990b041152cea5",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p><a href=\"https://www.bilibili.com/video/BV1Wa4y1j7kJ/\">https://www.bilibili.com/video/BV1Wa4y1j7kJ/</a></p>\n</div>",
		"title": "超棒的Git教学视频，干货满满",
		"last_reply_at": "2020-09-28T05:19:09.306Z",
		"good": false,
		"top": false,
		"reply_count": 0,
		"visit_count": 444,
		"create_at": "2020-09-28T05:19:09.306Z",
		"author": {
			"loginname": "JavaCS3",
			"avatar_url": "https://avatars3.githubusercontent.com/u/4168698?v=4&s=120"
		}
	}, {
		"id": "5f6718d1c1c67a7dd9aff3df",
		"author_id": "55be0508f36f579657fc561c",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p>地址：<a href=\"https://www.hello1234567.com/#/\">hello1234567.com</a>\n看Gif\n<img src=\"http://qgy8uqy31.hn-bkt.clouddn.com/hello1234567.com.gif\" alt=\"1.jpg\"></p>\n</div>",
		"title": "有点酷的个人主页",
		"last_reply_at": "2020-09-28T02:44:38.915Z",
		"good": false,
		"top": false,
		"reply_count": 5,
		"visit_count": 1477,
		"create_at": "2020-09-20T08:54:41.515Z",
		"author": {
			"loginname": "andygithubchen",
			"avatar_url": "https://avatars0.githubusercontent.com/u/7202281?v=4&s=120"
		}
	}, {
		"id": "5f322ce36c9ee864cf0e4751",
		"author_id": "5f322c8a2799ce64a0aabac9",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><blockquote>\n<p>我使用 Vue 和 React 已经很长一段时间了，两个框架上实践代码量都在 10 万行以上。不得不说两者都是很 nice 的，帮助开发者减少很多工作量，这类框架是现代化前端开发必备的。然而 Vue 和 React 两者之间的选择并不像选择苹果或香蕉一样简单，两者在工程实践上的差距让我们逐渐放弃了 Vue。本文以不一样的角度对两者进行深度对比。</p>\n</blockquote>\n<p><a href=\"https://taskhub.work/article/79319258450055168\">为什么我们放弃了 Vue？Vue 和 React 深度对比</a></p>\n</div>",
		"title": "为什么我们放弃了 Vue？Vue 和 React 深度对比",
		"last_reply_at": "2020-09-28T02:42:11.025Z",
		"good": false,
		"top": false,
		"reply_count": 10,
		"visit_count": 4310,
		"create_at": "2020-08-11T05:30:11.408Z",
		"author": {
			"loginname": "Q-Qplus1s",
			"avatar_url": "https://avatars1.githubusercontent.com/u/50064165?v=4&s=120"
		}
	}, {
		"id": "5f71383172af8c02d3f8da4a",
		"author_id": "597ee3db68aa87c774e5edac",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p><img src=\"https://p2.ssl.qhimgs4.com/t0107c5358f7e3258c9.png\" alt></p>\n<p>RESTful 是目前比较主流的一种用来设计和编排服务端 API 的一种规范。在 RESTful API 中，所有的接口操作都被认为是对资源的 CRUD，使用 URI 来表示操作的资源，请求方法表示具体的操作，响应状态码表示操作结果。之前使用 RESTful 的规范写过不少 API 接口，我个人认为它最大的好处就是帮助我们更好的去规划整理接口，如果还是按照以前根据需求来写接口的话接口的复用率不高不说，整个项目也会变得非常的杂乱。</p>\n<p>文件即路由是 ThinkJS 的一大特色，比如 <code>/user</code> 这个路由等价于 <code>/user/index</code>，会对应到 <code>src/controller/user.js</code> 中的 <code>indexAction</code> 方法。那么就以 <code>/user</code> 这个 API 为例，在 ThinkJS 中要创建 RESTful 风格的 API 需要以下两个步骤：</p>\n<ol>\n<li>运行命令 <code>thinkjs controller user -r</code> 会创建路由文件 <code>src/controller/user.js</code></li>\n<li>在 <code>src/config/router.js</code> 中使用自定义路由标记该路由为 RESTful 路由<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F;src&#x2F;config&#x2F;router.js\nmodule.exports = [\n  [&#x27;&#x2F;user&#x2F;:id?&#x27;, &#x27;rest&#x27;]\n];\n</code></pre></li>\n</ol>\n<p>这样我们就完成了一个 RESTful 路由的初始化，这个资源的所有操作都会被映射成路由文件中对应请求方法的 Action 函数中，例如：</p>\n<ul>\n<li><code>GET /user</code> 获取用户列表，对应 <code>getAction</code> 方法</li>\n<li><code>GET /user/:id</code> 获取某个用户的详细信息<code>，也对应</code>getAction` 方法</li>\n<li><code>POST /user</code> 添加一位用户，对应 <code>postAction</code> 方法</li>\n<li><code>PUT /user/:id</code> 更新一位用户资料，对应 <code>putAction</code> 方法</li>\n<li><code>DELETE /user/:id</code> 删除一位用户，对应 <code>deleteAction</code> 方法</li>\n</ul>\n<p>然而每个 RESTful 路由都需要去 <code>router.js</code> 中写一遍自定义路由未免过于麻烦。所以我写了一个中间件 <a href=\"https://github.com/thinkjs/think-router-rest\">think-router-rest</a>，只需要在 Controller 文件中使用 <code>_REST</code> 静态属性标记一下就可以将其转换成 RESTful 路由了。</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F;src&#x2F;controller&#x2F;user.js\nmodule.exports = class extends think.Controller {\n  static get _REST() {\n    return true;\n  }\n\n  getAction() {}\n  postAction() {}\n  putAction() {}\n  deleteAction() {}\n}\n</code></pre><p>简单的了解了一些入门知识之后，下面我就讲一些我平常开发 RESTful 接口时对我有帮助的一些知识点，希望对大家开发项目会有所帮助。</p>\n<h2>表结构梳理</h2>\n<p>拿到需求之后千万不要急着先敲键盘，一定要把表结构整理好。其实说是表结构，实际上就是对资源的整理。以 MySQL 为例，一般一类资源就会是一张表，比如 <code>user</code> 用户表，<code>post</code> 文章表等。当你把表罗列出来之后那么其实你的 RESTful 接口就已经七七八八了。比如你有一张 <code>post</code> 文章表，那么之后你的接口肯定会有：</p>\n<ul>\n<li><code>GET /post</code> 获取文章列表</li>\n<li><code>GET /post/1</code> 获取 <code>id=1</code> 的文章信息</li>\n<li><code>POST /post</code> 添加文章</li>\n<li><code>PUT /post/1</code> 修改 <code>id=1</code> 的文章信息</li>\n<li><code>DELETE /post/1</code> 删除 <code>id=1</code> 的文章</li>\n</ul>\n<p>当然不是所有的事情都这么完美，有时候接口的操作可能五花八门，这种时候我们就要尽量的去思考接口行为的本质是什么。比如说我们要迁移文章给其它用户，这时候你就要思考它其实本质上就是修改 <code>post</code> 文章资源的 <code>user_id</code> 属性，最终还是会映射到 <code>PUT /post/1</code> 接口中来。</p>\n<p>想清楚有哪些资源能帮助你更好的创建表，接下来就要想清楚资源之间的关系了，它能帮助你更好的创建表结构。一般资源之间会存在以下几类关系：</p>\n<ul>\n<li>一对一：如果一位 <code>user</code> 只能创建一篇 <code>post</code> 文章，则是一对一的关系。在 <code>post</code> 中可以使用 <code>user_id</code> 字段来关联对应的 <code>user</code> 数据，在 <code>user</code> 中也可以使用 <code>post_id</code> 来关联对应的文章数据。</li>\n<li>一对多：如果一位 <code>user</code> 能创建多篇 <code>post</code> 文章，则是一对多的关系。在 <code>post</code> 中可以使用 <code>user_id</code> 字段来关联对应的 <code>user</code> 数据。</li>\n<li>多对多：如果一位 <code>user</code> 可以创建多篇 <code>post</code> 文章，一篇 <code>post</code> 文章也可以有多位 <code>user</code>，则是多对多的关系。多对多关系没办法通过一个字段来表示，这时候为了描述清楚多对多的关系，就需要一张中间表 <code>user_post</code>，用来做 <code>user</code> 和 <code>post</code> 表的关系映射。表内部的 <code>user_id</code> 表示 <code>user</code> 表 ID，<code>post_id</code> 则表示 <code>post</code> 表对应数据 ID。</li>\n</ul>\n<pre class=\"prettyprint\"><code>mysql&gt; DESCRIBE user;\n+-------+--------------+------+-----+---------+----------------+\n| Field | Type         | Null | Key | Default | Extra          |\n+-------+--------------+------+-----+---------+----------------+\n| id    | int(11)      | NO   | PRI | NULL    | auto_increment |\n| name  | varchar(100) | YES  |     | NULL    |                |\n+-------+--------------+------+-----+---------+----------------+\n2 rows in set (0.01 sec)\n\nmysql&gt; DESCRIBE post;\n+-------+---------+------+-----+---------+----------------+\n| Field | Type    | Null | Key | Default | Extra          |\n+-------+---------+------+-----+---------+----------------+\n| id    | int(11) | NO   | PRI | NULL    | auto_increment |\n| title | text    | YES  |     | NULL    |                |\n+-------+---------+------+-----+---------+----------------+\n2 rows in set (0.00 sec)\n\nmysql&gt; DESCRIBE user_post;\n+---------+---------+------+-----+---------+----------------+\n| Field   | Type    | Null | Key | Default | Extra          |\n+---------+---------+------+-----+---------+----------------+\n| id      | int(11) | NO   | PRI | NULL    | auto_increment |\n| user_id | int(11) | NO   |     | NULL    |                |\n| post_id | int(11) | NO   |     | NULL    |                |\n+---------+---------+------+-----+---------+----------------+\n3 rows in set (0.00 sec)\n</code></pre><p>作为一款约定大于配置的 Web 框架，ThinkJS 默认规定了请求 RESTful 资源的时候，会根据当前资源 URI 找到对应的资源表，比如 <code>GET /post</code> 会找到 <code>post</code> 表。然后再进行查询的之后会进行自动的关联查询。例如当你在模型里标记了 <code>post</code> 和 <code>user</code> 是一对多的关系，且 <code>post</code> 表中存在 <code>user_id</code> 字段（也就是关联表表名 + <code>_id</code>），会自动关联获取到 <code>project</code> 对应的 <code>user</code> 数据。这在进行数据操作的时候会节省非常多的工作量。</p>\n<h2>登录登出</h2>\n<p>当我第一次写 RESTful API 的时候，我就碰到了这个难题，平常大家都是使用 <code>/login</code>, <code>/logout</code> 来表示登录和登出操作的，如何使用资源的形式来表达就成了问题。后来想了下登录操作中涉及到的资源其实就是登录后的 Token 凭证，本质上登录就是凭证的创建与获取，登出就是凭证的删除。</p>\n<ul>\n<li><code>GET /token</code>：获取凭证，用来判断是否登录</li>\n<li><code>POST /token</code>：创建凭证，用来进行登录操作</li>\n<li><code>DELETE /token</code>：删除凭证，用来进行登出操作</li>\n</ul>\n<h2>权限校验</h2>\n<p>我们平常写接口逻辑，其实会有很大一部分的工作量是用来做用户请求的处理。包括用户权限的校验和用户参数的校验处理等，这些逻辑其实和主业务场景没有太大的关系。为了将这些逻辑与主业务场景进行解耦，基于 Controller 层之上，ThinkJS 会存在一层 <a href=\"https://thinkjs.org/zh-cn/doc/3.0/logic.html\">Logic</a> 逻辑校验层。Logic 与 Controller 一一映射，并提供了一些常用的校验方法，我们可以将权限校验，参数校验，参数处理等逻辑放在这里，让 Controller 只做真正的业务逻辑。</p>\n<p>在 Logic 和 Controller 中，都存在 <code>__before()</code> <a href=\"https://thinkjs.org/zh-cn/doc/3.0/controller.html#toc-083\">魔术方法</a>，当前 Controller 内所有的 Action 执行之前都会先执行 <code>__before()</code> 操作。利用这个特性，我们可以将一些通用的权限校验逻辑放在这里，比如最平常的登录判断逻辑，这样就不需要在每个地方都做判断了。</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F;src&#x2F;logic&#x2F;base.js\nmodule.exports = class extends think.Logic {\n  async __before() {\n    &#x2F;&#x2F;接口 CSRF 校验\n    if (!this.isCli &amp;&amp; !this.isGet) {\n      const referrer = this.referrer(true);\n      if (!&#x2F;^xxx\\.com$&#x2F;.test(referrer)) {\n        return this.fail(&#x27;请不要在非其它网站中使用该接口！&#x27;);\n      }\n    }\n\n    &#x2F;&#x2F; 非登录接口需要做登录校验\n    const userInfo = await this.session(&#x27;userInfo&#x27;) || {};\n    if(think.isEmpty(userInfo) &amp;&amp; !&#x2F;\\&#x2F;(?:token)\\.js&#x2F;.test(this.__filename)) {\n      return this.ctx.throw(401, &#x27;UnAuthorized&#x27;);\n    }\n  }\n}\n\n&#x2F;&#x2F;src&#x2F;logic&#x2F;user.js\nconst Base = require(&#x27;.&#x2F;base.js&#x27;);\nmodule.exports = class extends Base {}\n</code></pre><p>创建一个 Base 基类，所有的 Logic 通过继承该基类就都能享受到 CSRF 和登录校验了。</p>\n<blockquote>\n<p>问：所有的请求都会实例化类，所以 <code>contructor</code> 本质上也会在所有的 Action 之前执行，那为什么还需要 <code>__before()</code> 魔术方法的存在呢？</p>\n<p>答：<code>constructor</code> 构造函数虽然有前置执行的特性，但是无法在保证顺序的情况下执行异步操作。构造函数前是不能使用 <code>async</code> 标记的，而 <code>__before()</code> 是可以的，这也是它存在的原因。</p>\n</blockquote>\n<h2>善用继承</h2>\n<p>在 RESTful API 中，我们其实会发现很多资源是具有从属关系的。比如一个项目下的用户对应的文章，这句话中的三种资源 <code>项目</code>，<code>用户</code> 和 <code>文章</code> 就是从属关系。在从属关系中包括权限、数据操作等也都是具有从属关系的。比如说文章属于用户，非该用户的话自然是无法看到对应的文章的。而用户又从属于项目，其它项目的人是无法操作该项目下的用户的。这就是所谓的从属关系。</p>\n<p>确立了从属关系之后我们会发现越到下级的资源在对其操作的时候要判断的权限就越多。以刚才的例子为例，如果说我们对项目资源进行操作的话，我们需要判断该用户是否在项目中。而如果要对项目下的用户文章进行操作的话，除了需要判断用户是否在项目中，还需要判断该文章是否是当前用户的。</p>\n<p>在这个例子中我们可以发现：**资源关系从属的话权限校验也会是从属关系，从属关系中级别越深的资源需要判断的权限越多。**面向对象语言中，继承是一个比较重要的功能，它最大的好处就是能帮助我们进行逻辑的复用。通过继承，我们能直接在子资源中复用父资源的校验逻辑，避免重复劳动。</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F;src&#x2F;logic&#x2F;base.js\nmodule.exports = class extends think.Logic {\n  async __before() {\n    const userInfo = this.session(&#x27;userInfo&#x27;) || {};\n    this.userInfo = this.ctx.state.userInfo = userInfo;\n    if(think.isEmpty(userInfo)) {\n      return this.ctx.throw(401);\n    }\n  }\n}\n\n&#x2F;&#x2F;src&#x2F;logic&#x2F;project&#x2F;base.js\nconst Base = require(&#x27;..&#x2F;base.js&#x27;);\nmodule.exports = class extends Base {\nasync __before() {\n    await super.__before();\n\n    const {team_id} = this.get();\n    const {id: user_id} = this.userInfo;\n    const permission = await this.model(&#x27;team_user&#x27;).where({team_id, user_id}).find();\n    \n    const {controller} = this.ctx;\n    &#x2F;&#x2F; 团队接口中只有普通用户只有权限调用获取邀请链接详细信息和接受邀请链接两个接口\n    if(controller !== &#x27;team&#x2F;invitation&#x27; &amp;&amp; (this.isGet &amp;&amp; !this.id)) {\n      if(think.isEmpty(permission)) {\n        return this.fail(&#x27;你没有权限操作该团队&#x27;);\n      }\n    }\n    \n    this.userInfo.role_id = permission.role_id;\n  }\n}\n\n&#x2F;&#x2F;src&#x2F;logic&#x2F;project&#x2F;user&#x2F;base.js\nconst Base = require(&#x27;..&#x2F;base&#x27;);\nmodule.eports = class extends Base {\n  async __before() {\n    await super.__before();\n    \n    const {role_id} = this.userInfo;\n    if(!global.EDITOR.is(role_id)) {\n      return this.fail(&#x27;你没有权限操作该文章&#x27;);\n    }\n  }\n}\n</code></pre><p>通过创建三个 Base 基类，我们将权限校验进行了合理的拆分同时又能保证校验的完整性。同级别的路由只要继承当前层级的 Base 基类就能享受到通用的校验逻辑。</p>\n<ul>\n<li><code>/project</code> 路由对应的 Logic 因为继承了 <code>src/logic/base.js</code> 所以实现了登录校验。</li>\n<li><code>/project/1/user</code> 路由对应的 Logic 因为继承了 <code>src/logic/project/base.js</code> 所以实现了登录校验以及是否在是项目成员的校验。</li>\n<li><code>/project/1/user/1/post</code> 路由对应的 Logic 因为继承了 <code>src/logic/project/user/base.js</code> 所以实现了登录校验、项目成员校验以及项目成员权限的校验。</li>\n</ul>\n<p>瞧，套娃就这么简单！</p>\n<h2>数据库操作</h2>\n<p>从属的资源在表结构上也有一定的反应。还是以之前的项目、用户和文章为例，一般来说你的文章表里会存在 <code>project_id</code> 和 <code>user_id</code> 两个关联字段来表示文章与用户和项目资源的关系（简单假设都是一对多的关系）。那么这时候实际上你对项目下的文章操作实际上都需要传入 <code>project_id</code> 和 <code>user_id</code> 这两个 WHERE 条件。</p>\n<p>ThinkJS 内部使用 <code>think-model</code> 来进行 SQL 数据库操作。它有一个特性是支持链式调用，我们可以这样写一个查询操作。</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F;src&#x2F;controller&#x2F;project&#x2F;user&#x2F;post.js\nmodule.exports = class extends think.Controller {\n  async indexAction() {\n    const ret = await this.model(&#x27;post&#x27;).where({project_id: 1}).where({user_id: 2}).select();\n    return this.success(ret);\n  }\n}\n</code></pre><p>利用这个特性，我们可以对操作进行优化，在 <code>constructor</code> 的时候将当前 Controller 下的通用 WHERE 条件 <code>project_id</code> 和 <code>user_id</code> 传入。这样我们在其它的 Action 操作的时候就不用每个都传一变了，同时也一定规避了可能会漏传限制条件的风险。</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F;src&#x2F;controller&#x2F;project&#x2F;user&#x2F;post.js\nmodule.exports = class extends think.Controller {\n  constructor(ctx) {\n    super(ctx);\n    const {project_id, user_id} = this.get();\n    this.modelInstance = this.model(&#x27;post&#x27;).where({project_id, user_id});\n  }\n\n  async getAction() {\n    const ret = await this.modelInstance.select();\n    return this.success(ret);\n  }\n}\n</code></pre><h2>后记</h2>\n<p>RESTful API 除了以上说的一些特性之外，它对响应状态码、接口的版本也有一定的规范定义。像 Github 这种 RESTful 实现比较好的网站还会实现 <code>Hypermedia API</code> 规范，在每个接口中会返回操作其它资源时需要的 RESTful 路由地址，方便调用者进行链式调用。</p>\n<p>当然 RESTful 只是实现 API 的一种规范，还有其它的一些实现规范，比如 GraphQL。关于 GraphQL 可以看看之前的文章<a href=\"https://zhuanlan.zhihu.com/p/40348143\">《GraphQL 基础实践》</a>，这里就不多做补充了。</p>\n</div>",
		"title": "如何使用 ThinkJS 优雅的编写 RESTful API",
		"last_reply_at": "2020-09-28T01:11:13.246Z",
		"good": false,
		"top": false,
		"reply_count": 0,
		"visit_count": 574,
		"create_at": "2020-09-28T01:11:13.246Z",
		"author": {
			"loginname": "lizheming",
			"avatar_url": "https://avatars2.githubusercontent.com/u/424491?v=4&s=120"
		}
	}, {
		"id": "5e8e9c3064259617c49a5025",
		"author_id": "5c81f15090c14711cc8cb87e",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p>教程讲了Nodejs的基础以及一些新特性、以及如何用nodejs封装一个类似于Express框架、还讲了Mongodb高级查询 聚合管道等内容</p>\n<p><strong>网盘链接</strong>： <a href=\"https://pan.baidu.com/s/1KmOwI3tKtMGwLXJhr5Om0w\">https://pan.baidu.com/s/1KmOwI3tKtMGwLXJhr5Om0w</a>      <strong>提取码</strong>：h87t</p>\n<p><strong>Nodejs+koa+Mongodb B站在线地址：</strong>  <a href=\"https://www.bilibili.com/video/av38925557/?p=1\">https://www.bilibili.com/video/av38925557/?p=1</a></p>\n<p><strong>Nodejs+Express+Mongodb B站在线地址：</strong>  <a href=\"https://www.bilibili.com/video/BV16f4y1U7oT?p=1\">https://www.bilibili.com/video/BV16f4y1U7oT?p=1</a></p>\n<p>拿走不谢  新手帮助还是挺大的</p>\n</div>",
		"title": "2020录制的Nodejs+Mongodb+Koa2+Express入门实战视频教程（网盘免费下载-B站免费看）",
		"last_reply_at": "2020-09-27T13:22:13.401Z",
		"good": false,
		"top": false,
		"reply_count": 13,
		"visit_count": 11625,
		"create_at": "2020-04-09T03:53:20.003Z",
		"author": {
			"loginname": "phonegap100",
			"avatar_url": "https://avatars1.githubusercontent.com/u/5773766?v=4&s=120"
		}
	}, {
		"id": "5f687f31d22a6b1d622c9bfd",
		"author_id": "5f687ba1d22a6b1d622c9bf4",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>如题，自学nodejs时遇到的一个问题，在读其他人的代码。</p>\n<pre class=\"prettyprint\"><code>&lt;td class=&quot;hidden-480&quot;&gt;\n    {{if $value.status==1}}\n    &lt;img src=&quot;{{__HOST__}}&#x2F;admin&#x2F;images&#x2F;yes.gif&quot; onclick=&quot;app.toggle(this,&#x27;admin&#x27;,&#x27;status&#x27;,&#x27;{{@$value._id}}&#x27;)&quot; &#x2F;&gt;\n    {{else}}\n    &lt;img src=&quot;{{__HOST__}}&#x2F;admin&#x2F;images&#x2F;no.gif&quot; onclick=&quot;app.toggle(this,&#x27;admin&#x27;,&#x27;status&#x27;,&#x27;{{@$value._id}}&#x27;)&quot; &#x2F;&gt;\n    {{&#x2F;if}}\n&lt;&#x2F;td&gt;\n\n&lt;td&gt;\n    &lt;div class=&quot;visible-md visible-lg hidden-sm hidden-xs btn-group center&quot;&gt;\n\n\n        &lt;a id=&#x27;***question at here***&#x27; href=&quot;{{__HOST__}}&#x2F;admin&#x2F;manage&#x2F;edit?id={{@$value._id}}&quot;&gt;\n\n            &lt;button class=&quot;btn btn-xs btn-info&quot;&gt;\n                &lt;i class=&quot;icon-edit bigger-120&quot;&gt;&lt;&#x2F;i&gt;\n            &lt;&#x2F;button&gt;\n        &lt;&#x2F;a&gt;\n\n        &lt;a href=&quot;{{__HOST__}}&#x2F;admin&#x2F;manage&#x2F;delete?id={{@$value._id}}&quot;&gt;\n\n\n            &lt;button class=&quot;btn btn-xs btn-danger&quot;&gt;\n                &lt;i class=&quot;icon-trash bigger-120&quot;&gt;&lt;&#x2F;i&gt;\n            &lt;&#x2F;button&gt;\n\n        &lt;&#x2F;a&gt;\n\n    &lt;&#x2F;div&gt;\n\n&lt;&#x2F;td&gt;\n</code></pre><p>最上面img如果点击会修改数据库状态并显示对应状态， 而加黑加粗的id=questionAtHere的标签点击之后直接发起了一个超链接，我想知道为什么会有这样的区别，以及各在什么时候使用。\n再次感谢大家宝贵的时间</p>\n</div>",
		"title": "前端的按钮，在都需要与后台交互数据的情况下，什么时候用js function，什么时候用超链接呢？求各位大神指导，第一次提问",
		"last_reply_at": "2020-09-27T12:37:41.472Z",
		"good": false,
		"top": false,
		"reply_count": 6,
		"visit_count": 1358,
		"create_at": "2020-09-21T10:23:45.009Z",
		"author": {
			"loginname": "Even0311",
			"avatar_url": "https://avatars3.githubusercontent.com/u/23709903?v=4&s=120"
		}
	}, {
		"id": "5f6b1edcd22a6b1d622ca0dc",
		"author_id": "5594b1fa47e6bdc30297eb0c",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>如题公司比较急招人，我也很希望能够推进这事，所以想问问大家知不知道其他什么 nodejs 的社区可以招人呀？小众或者不能发招聘帖也没关系，因为我自己也是主攻 Javascript 开发的所以也想借此机会开拓下视野。</p>\n<p>谢谢 😃</p>\n</div>",
		"title": "请问国内还有哪些 nodejs 社区？",
		"last_reply_at": "2020-09-27T02:15:46.732Z",
		"good": false,
		"top": false,
		"reply_count": 20,
		"visit_count": 1341,
		"create_at": "2020-09-23T10:09:32.568Z",
		"author": {
			"loginname": "xieaolin",
			"avatar_url": "https://avatars0.githubusercontent.com/u/858724?v=4&s=120"
		}
	}, {
		"id": "5f6fe105f9736b02ceada6cd",
		"author_id": "50b5bc5d637ffa4155091236",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>比如从mysql切换到oracle 或者postgre</p>\n</div>",
		"title": "实际项目中，切换数据库的案例多吗",
		"last_reply_at": "2020-09-27T01:32:52.815Z",
		"good": false,
		"top": false,
		"reply_count": 2,
		"visit_count": 461,
		"create_at": "2020-09-27T00:47:01.262Z",
		"author": {
			"loginname": "yakczh",
			"avatar_url": "https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"
		}
	}, {
		"id": "5f6fe60b72af8c02d3f8d781",
		"author_id": "52cce7827a15a38466a94b4b",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><h1>前端周刊：2020-16期</h1>\n<p><a href=\"https://cn.bing.com/search?q=%E9%99%86%E5%AE%B6%E5%98%B4%E9%87%91%E8%9E%8D%E8%B4%B8%E6%98%93%E5%8C%BA\"><img src=\"/img/bing/20200903.png?imageMogr2/thumbnail/960x\" alt></a></p>\n<h2>前端开发</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&amp;mid=2649869912&amp;idx=1&amp;sn=afdee592f13adefdd442b8ff934d197f\">谈谈验证能力</a></li>\n</ul>\n<blockquote>\n<p>调研是了解诉求，以及寻找可能的方案，而验证就是检验诉求及方案的可行性。</p>\n</blockquote>\n<ul>\n<li><a href=\"https://www.oschina.net/news/118175/chrome-85-released\">Chrome 85 稳定版发布，页面加载速度提升 10%</a></li>\n</ul>\n<blockquote>\n<p>Chrome发展太迅猛了。</p>\n</blockquote>\n<ul>\n<li><a href=\"https://g2plot.antv.vision/zh/docs/manual/introduction\">g2plot - 一套简单、易用、并具备一定扩展能力和组合能力的统计图表库</a></li>\n</ul>\n<blockquote>\n<p>1.0版本了，感觉可以找个项目试试</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/reng99/blogs/issues/66\">JavaScript – Map vs ForEach</a></li>\n</ul>\n<blockquote>\n<p>JavaScript中的Map和ForEach有什么区别？</p>\n</blockquote>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/150083887?from_voters_page=true\">有了 vite，还需要 webpack 么？</a></li>\n</ul>\n<blockquote>\n<p>webpack编译大型项目太吃CPU了，vite直击痛点，凭Vue全家桶的带货能力，vite非常有戏</p>\n</blockquote>\n<ul>\n<li><a href=\"https://developers.google.com/web/tools/workbox/modules/workbox-webpack-plugin\">workbox-webpack-plugin</a></li>\n</ul>\n<blockquote>\n<p>辅助实现PWA的webpack插件</p>\n</blockquote>\n<ul>\n<li><a href=\"https://www.cnblogs.com/olive27/p/11646443.html\">资源管理器显示不出来文件的git图标标志</a></li>\n</ul>\n<blockquote>\n<p>很多人都有这个困扰把，解决方法在这里</p>\n</blockquote>\n<h2>行业周边</h2>\n<ul>\n<li><a href=\"https://www.aliyun.com/minisite/goods?userCode=y31qmczl\">【阿里云】最高￥2000云产品通用代金券</a></li>\n</ul>\n<blockquote>\n<p>新客购云产品一折起 最高2000元红包</p>\n</blockquote>\n<ul>\n<li><a href=\"https://url.cn/abdjJNhu\">【腾讯云】云产品限时秒杀，爆款1核2G云服务器，首年99元</a></li>\n</ul>\n<blockquote>\n<p>【腾讯云】云产品限时秒杀，爆款1核2G云服务器，首年99元</p>\n</blockquote>\n<ul>\n<li><a href=\"https://daily.zhihu.com/story/9726870\">短信广告的退订内幕</a></li>\n</ul>\n<blockquote>\n<p>很多促销广告短信都说回复 TD 退订，但是回复了 TD 之后，为什么同一个号码还会发短信过来？</p>\n</blockquote>\n<ul>\n<li><a href=\"https://limboy.me/2020/08/01/specialize-or-generalist/\">应该成为专才还是通才</a></li>\n</ul>\n<blockquote>\n<p>“机会留给有准备的人”的另一个版本</p>\n</blockquote>\n<h2>加群交流</h2>\n<p>添加好友，备注“加群”</p>\n<p><img src=\"https://frontend-weekly.com/img/a/refined-x.jpg\" alt=\"refned_x\"></p>\n</div>",
		"title": "前端周刊：2020-16期",
		"last_reply_at": "2020-09-27T01:08:27.994Z",
		"good": false,
		"top": false,
		"reply_count": 0,
		"visit_count": 1030,
		"create_at": "2020-09-27T01:08:27.994Z",
		"author": {
			"loginname": "tower1229",
			"avatar_url": "https://avatars1.githubusercontent.com/u/4016839?v=4&s=120"
		}
	}, {
		"id": "5f616c02d22a6b1d622c9173",
		"author_id": "55be0508f36f579657fc561c",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p>免费，安全，简单易用界面简洁。支持团队多人协作，只需安装 chrome 浏览器 api-mom 扩展就可以对 API 进行测试。</p>\n<ol>\n<li>项目里的文件夹，接口列表，接口 Tab 都支持鼠标拖动排序。</li>\n<li>编辑接口时支持常用快捷键 Ctrl + S 保存。</li>\n<li>接口文档和测试结果并排，一切都在眼前，方便校对。</li>\n<li>接口越来越多，可以用模糊搜索快速找出。</li>\n<li>浏览模式 /编辑模式，安全操作。</li>\n<li>可以加入团队成员，并做权限控制。</li>\n<li>有白昼、夜晚两种主题。</li>\n</ol>\n<p>网址：<a href=\"https://www.api-mom.com/?from=cnode\">api-mom</a></p>\n<p><img src=\"//static.cnodejs.org/FgO14r8qJM50ZX26aBt4JJzYdd0Y\" alt=\"1.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/Frjrsb-Eup88tVubsR3VzFlEkm4i\" alt=\"2.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FsZvIXZ2-i7mCASJKLvVZGu13SZ4\" alt=\"3.jpg\"></p>\n</div>",
		"title": "api-mom 一个 API 在线管理工具",
		"last_reply_at": "2020-09-26T13:41:46.953Z",
		"good": false,
		"top": false,
		"reply_count": 3,
		"visit_count": 2900,
		"create_at": "2020-09-16T01:36:02.160Z",
		"author": {
			"loginname": "andygithubchen",
			"avatar_url": "https://avatars0.githubusercontent.com/u/7202281?v=4&s=120"
		}
	}, {
		"id": "5f6f2e36f9736b02ceada684",
		"author_id": "5f566bb1d22a6b1d622c813f",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><h2>下载地址：<a href=\"http://www.97yrbl.com/t-428.html\">百度网盘</a></h2>\n<p>第1章 课程介绍\n介绍这门课程要讲的主要内容，讲解方式、课程主线、以及能有的收获。\n1-1 课程导学 【课程背景，大纲速览】 试看\n第2章 性能优化的指标和工具 (告别前端小白，成为大神的必经之路)\n本章带大家认识前端优化优化的重要性，了解当前的行业标准，流行的模型和测量工具，以及如何有针对性的进行性能的测量，解读性能报告；还会学习到很多与性能相关的APIs的使用和实用的例子。\n2-1 为什么要进行Web性能优化【企业刚需】\n2-2 性能指标和优化目标【了解行业标准】\n2-3 RAIL测量模型【黄金指南】\n2-4 使用WebPageTest评估Web网站性能【快捷好用的在线分析工具】\n2-5 使用LightHouse分析性能【一站式全面呈现性能指标】\n2-6 使用Chrome DevTools分析性能【最大法宝】\n2-7 常用的性能测量APIs【不可不知，打开精细化、自定义测量的大门】 试看\n第3章 渲染优化 (与浏览器为友，共进退)\n本章涵盖现代浏览器的渲染原理，详细解读各个环节的作用和相互联系，具体讲解如何减少和避免回流和重绘，还有如何解决布局抖动的问题。\n3-1 浏览器渲染原理和关键渲染路径【大厂前端面试必考】\n3-2 回流与重绘, 如何避免布局抖动\n3-3 使用FastDom【防止布局抖动的利器】\n3-4 复合线程与图层【深入渲染流水线的最后一站】\n3-5 避免重绘【必学，加速页面呈现】\n3-6 高频事件防抖【解救页面卡顿的秘药】\n3-7 React时间调度实现【中高级前端需要了解的React调度原理】\n第4章 代码优化 (快来看看怎样写出真正高性能的代码)\n本章主要了解在代码层面上可以进行的极致优化，涉及JavaScript，CSS和HTML的方方面面；较深的理论知识会做到深入浅出的讲解，让你了解如何配合JS引擎写会可以被它有效优化的代码。\n4-1 JS开销和如何缩短解析时间【为什么我的JS运行慢】\n4-2 配合V8 有效优化代码【路走对了才能快】\n4-3 函数优化【必会】\n4-4 对象优化【JS对象避坑地图】\n4-5 HTML优化【必会】\n4-6 CSS对性能的影响 【必会】\n第5章 资源优化 (经典性能优化解决方案)\n本章学习如何对Web加载的资源进行有效的优化，不仅涉及压缩的知识，还详细讲解一些针对图片、字体类资源本身特性和使用方式不同可以带来的性能提升。\n5-1 资源的压缩与合并【见效最明显的优化方法】\n5-2 图片格式优化【多种图片格式，哪种最合适】\n5-3 图片加载优化【突破大型网站图片加载的瓶颈】\n5-4 字体优化【千万不可忽略】\n第6章 构建优化(揭开webpack性能优化的内幕)\n本章讲解基于Webpack项目如何进行全方位的性能优化，让你的企业级应用速度翻倍。以一个基本webpack工程开始，逐项讲解如何进行配置，达到优化的效果。\n6-1 webpack的优化配置【了解这些优化配置才敢说会用webpack】\n6-2 webpack的依赖优化【小改动，大作用】\n6-3 基于webpack的代码拆分【让网站按需加载】\n6-4 手把手教你做webpack的资源压缩\n6-5 基于webpack的持久化缓存【大型企业级应用的必会技能】\n6-6 基于webpack的应用大小监测与分析【webpack性能分析的法宝】\n6-7 React按需加载的实现方式【中高级前端必会的React按需加载】\n第7章 传输加载优化（前沿技术解决高访问量网站性能优化问题）\n本章包括了前沿的网络加载优化技术，从了解现代网络上的问题和多样的流行技术解决方案，给大型、高访问量的网站带来质的飞跃。\n7-1 启用压缩Gzip【必会的传输压缩方案】\n7-2 启用Keep Alive【通过一个参数提速连接】\n7-3 HTTP资源缓存【必会的HTTP缓存方法】\n7-4 一次性理解Service workers技术，给网站提速\n7-5 HTTP 2的性能提升\n7-6 用流行的SSR技术给前端减负\n第8章 前沿优化解决方案\n本章在之前章节知识点的基础上，补充了更多流行的Web性能优化技术。以例子为导向掌握用法。\n8-1 拯救移动端图标SVG【拯救移动端图标】\n8-2 使用Flexbox优化布局（上）\n8-3 使用Flexbox优化布局（下）\n8-4 优化资源加载的顺序【给资源设置优先级】\n8-5 预渲染页面【提前完成任务的意义】\n8-6 Windowing提高列表性能【开源节流，用什么画什么】\n8-7 使用骨架组件减少布局移动【论占位置的重要性】\n第9章 性能优化问题面试指南【能胸有成竹的一步】\n本章在之前章节的基础之上，针对当前高频的性能优化相关问题进行剖析，让大家同时了解应对的方法，如何准确理解问题，抓住重点进行作答。\n9-1 Web加载&amp;渲染基本原理\n9-2 首屏加载优化\n9-3 JavaScript 内存管理\n第10章 互联网外企offer与立足之道【能不能出国，就看这一章了】\n本章向大家介绍互联网外企面试中常见流程和考察重点，同时带来在外企生存的职业经验分享。\n10-1 互联网外企offer\n10-2 英语与工作\n本课程已完结</p>\n</div>",
		"title": "前端性能优化--6大角度综合型优化方案",
		"last_reply_at": "2020-09-26T12:04:06.375Z",
		"good": false,
		"top": false,
		"reply_count": 0,
		"visit_count": 1267,
		"create_at": "2020-09-26T12:04:06.375Z",
		"author": {
			"loginname": "yrbl97",
			"avatar_url": "https://avatars1.githubusercontent.com/u/70911396?v=4&s=120"
		}
	}, {
		"id": "5ef8528213f8b244e57cbcc3",
		"author_id": "5ec35c50a87fc8583363d189",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p><strong>Eggjs+Tarojs+AntDesign+React+Graphql+Typescrip-GlobeCat商城系统-全栈无人商城开源版</strong>\nGlobeCat商城系统-有地道全栈无人商城：有地道项目是一套无人电商售货系统，包含前台商城系统（小程序，快应用，h5，APP）、后台管理系统以及服务端。技术栈：Eggjs+Tarojs+AntDesign+React+Graphql+Typescript，我们做全网首个无人超市开源。</p>\n<p><strong>演示图：</strong>\n小程序端：<img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gg82kkkfszj30k015mqv5.jpg\" alt>\n管理端：<img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gg82nuvjm4j31lc0u0wi1.jpg\" alt></p>\n<p><strong>开源地址：<a href=\"https://gitee.com/GlobeCat/youdidao-unmanned-shop\">https://gitee.com/GlobeCat/youdidao-unmanned-shop</a></strong>\n<strong>交流群：</strong> <img src=\"//static.cnodejs.org/FkeuijkU4y65HNaSA7ZbRP19OSvP\" alt>\n<strong>联系QQ: 59187993</strong>\n<strong>反馈邮箱:  <a href=\"mailto:layzhou@foxmail.com?subject=%E6%9C%89%E5%9C%B0%E9%81%93\">layzhou@foxmail.com</a></strong></p>\n</div>",
		"title": "分享一个电商系统-可对接无人零售：Eggjs+Tarojs+AntDesign+React+Graphql+Typescript",
		"last_reply_at": "2020-09-26T07:17:18.999Z",
		"good": false,
		"top": false,
		"reply_count": 14,
		"visit_count": 8210,
		"create_at": "2020-06-28T08:19:14.654Z",
		"author": {
			"loginname": "lay-zhou",
			"avatar_url": "https://avatars2.githubusercontent.com/u/41415384?v=4&s=120"
		}
	}, {
		"id": "554b34afb68166372e6000fb",
		"author_id": "535cbb096b02f25e580123e9",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>本来不想买vpn\n最近平常上的搜索都给封了\n所以，便宜的vpn也认了\n当然，还是免费的最好啦\n对这种闭关锁国的寡妇网表示鄙视\n各位大大，给点推荐吧</p>\n</div>",
		"title": "求上谷歌方法",
		"last_reply_at": "2020-09-25T09:42:15.360Z",
		"good": false,
		"top": false,
		"reply_count": 53,
		"visit_count": 11750,
		"create_at": "2015-05-07T09:47:27.812Z",
		"author": {
			"loginname": "CarlosRen",
			"avatar_url": "https://avatars0.githubusercontent.com/u/6012322?v=4&s=120"
		}
	}, {
		"id": "53c8830ec9507b4044af2bbd",
		"author_id": "53666e836839d5a7220003b5",
		"content": "<div class=\"markdown-text\"><p>要vpn的，greenvpn就是个渣渣：（\nwin7 x64上刚连上，就爆出dll错误了⊙﹏⊙b汗 是不是里面放有木马？</p>\n</div>",
		"title": "求翻樯神器：）......",
		"last_reply_at": "2020-09-25T09:42:05.215Z",
		"good": false,
		"top": false,
		"reply_count": 18,
		"visit_count": 11301,
		"create_at": "2014-07-18T02:14:38.141Z",
		"author": {
			"loginname": "kingapple",
			"avatar_url": "https://avatars.githubusercontent.com/u/6572403?v=2&s=120"
		}
	}, {
		"id": "545721506537f4d52c414d88",
		"author_id": "51f0f267f4963ade0e08f503",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>rt</p>\n</div>",
		"title": "github 的 gist 被屏蔽了?",
		"last_reply_at": "2020-09-25T09:37:32.824Z",
		"good": false,
		"top": false,
		"reply_count": 11,
		"visit_count": 8758,
		"create_at": "2014-11-03T06:31:44.959Z",
		"author": {
			"loginname": "lellansin",
			"avatar_url": "https://avatars2.githubusercontent.com/u/2081487?v=4&s=120"
		}
	}, {
		"id": "596eb7768f05de0819fdb301",
		"author_id": "538ebff9c3ee0b58208376c7",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>如题。知道内情的进来说说？<a href=\"/user/alsotang\">@alsotang</a> and <a href=\"/user/i5ting\">@i5ting</a>？</p>\n</div>",
		"title": "听说明年2月之前要禁止所有个人用户使用VPN，是真的吗？",
		"last_reply_at": "2020-09-25T09:35:32.325Z",
		"good": false,
		"top": false,
		"reply_count": 49,
		"visit_count": 14298,
		"create_at": "2017-07-19T01:35:50.929Z",
		"author": {
			"loginname": "zhanzhenzhen",
			"avatar_url": "https://avatars3.githubusercontent.com/u/731796?v=4&s=120"
		}
	}];


	exports.rootData = rootData;
